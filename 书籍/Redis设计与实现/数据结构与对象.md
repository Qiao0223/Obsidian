# 1. 简单动态字符串
## 1.1. SDS 的结构定义
```
struct sdshdr {
    int len;    // buf 中已使用的字节数，即字符串长度
    int free;   // buf 中未使用的字节数
    char buf[]; // 字节数组，用于存储字符串数据
};
```
## 1.2. SDS 的优点

- **常数时间获取字符串长度**：由于 SDS 结构中维护了 len 字段，获取字符串长度的操作时间复杂度为 O(1)，避免了 C 字符串中需要遍历整个字符串的问题。
- **防止缓冲区溢出**：SDS 在执行修改操作前，会检查并自动扩展内存，避免了 C 字符串中常见的缓冲区溢出问题。
- **减少内存重分配次数**：SDS 采用空间预分配和惰性空间释放策略，减少了频繁的内存分配和释放操作，提高了性能。
- **二进制安全**：SDS 不依赖于空字符 `\0` 来标识字符串结束，因此可以安全地存储任意二进制数据。
- **兼容部分 C 字符串函数**：SDS 的 buf 末尾仍保留了一个 `\0` 字符，使其在需要时可以与 C 的字符串函数兼容。

## 1.3. SDS 与 C 字符串的对比
|特性|C 字符串|SDS|
|---|---|---|
|长度获取|O(N)，需遍历|O(1)，直接读取 len 字段|
|缓冲区溢出风险|高|低，自动扩展内存|
|内存重分配频率|高|低，采用预分配和惰性释放策略|
|二进制安全|否|是|
|与 C 函数兼容性|完全兼容|兼容部分函数|
# 2. 链表
## 2.1. 链表结构
### 1. 链表节点（listNode）
每个节点包含：
- `prev`：指向前一个节点的指针
- `next`：指向后一个节点的指针
- `value`：指向节点存储的数据的指针

这使得链表可以在两个方向上进行遍历。
### 2. 链表结构体（list）

整个链表结构体包含：
- `head`：指向链表头节点的指针
- `tail`：指向链表尾节点的指针
- `len`：链表中节点的数量
- 函数指针：用于定义节点值的复制、释放和匹配操作

## 2.2. 特性

- **双向性**：每个节点都包含前后指针，支持从任意节点向前或向后遍历。
- **无环性**：链表的头节点的 `prev` 和尾节点的 `next` 都指向 `NULL`，表示链表的开始和结束。
- **带头尾指针**：链表结构体中包含指向头尾节点的指针，便于在 O(1) 时间内访问链表的两端。
- **长度计数器**：链表结构体中维护了一个计数器，记录链表中节点的数量，获取长度的操作时间复杂度为 O(1)。
- **多态性**：通过函数指针，链表可以存储和操作多种类型的数据。

# 3. 字典
## 3.1. 结构

Redis 的字典主要由以下几个结构组成：
### 1. `dictEntry`：哈希表节点

每个节点表示一个键值对，结构如下：
```
typedef struct dictEntry {
    void *key;             // 键
    union {
        void *val;         // 值（可以是指针）
        uint64_t u64;      // 64 位无符号整数
        int64_t s64;       // 64 位有符号整数
    } v;
    struct dictEntry *next; // 指向下一个节点，解决哈希冲突
} dictEntry;
```
### 2. `dictht`：哈希表

`dictht` 结构表示一个哈希表，包含以下字段：

```
typedef struct dictht {
    dictEntry **table;     // 哈希表数组
    unsigned long size;    // 哈希表大小
    unsigned long sizemask;// 哈希表大小掩码，用于计算索引值
    unsigned long used;    // 当前已使用的节点数量
} dictht;
```

- `table`：是一个数组，数组的每个元素是指向 `dictEntry` 的指针。
- `size`：表示哈希表的大小，即 `table` 数组的长度。
- `sizemask`：等于 `size - 1`，用于快速计算索引值。
- `used`：表示哈希表中已使用的节点数量。

### 3. `dict`：字典结构

`dict` 结构是对哈希表的封装，支持动态扩容和渐进式 rehash，结构如下：[阿里云开发者社区+7腾讯云+7CSDN博客+7](https://cloud.tencent.com/developer/article/1005121?utm_source=chatgpt.com)

```
typedef struct dict {
    dictType *type;        // 类型特定函数
    void *privdata;        // 私有数据
    dictht ht[2];          // 哈希表，支持渐进式 rehash
    long rehashidx;        // rehash 进度，-1 表示未进行
    unsigned long iterators; // 当前正在使用的迭代器数量
} dict;
```

- `ht[0]`：正常使用的哈希表。
- `ht[1]`：在 rehash 过程中使用的新哈希表。
- `rehashidx`：记录 rehash 的进度，-1 表示未进行。
- `iterators`：表示当前正在使用的迭代器数量。

## 3.2. 哈希冲突与解决方案

Redis 使用链地址法解决哈希冲突。当多个键的哈希值相同时，这些键值对会被存储在同一个桶中，并通过链表连接。
## 3.3. 渐进式 Rehash

为了保持哈希表的性能，Redis 会在以下情况下触发哈希表的扩容或缩容：
- 当哈希表的负载因子超过一定阈值时，触发扩容。
- 当哈希表的负载因子低于一定阈值时，触发缩容。

Redis 采用渐进式 rehash（Incremental Rehash）策略，将 rehash 操作分散到多个步骤中，以避免一次性 rehash 带来的性能问题。

在 rehash 过程中，Redis 会逐步将 `ht[0]` 中的键值对迁移到 `ht[1]` 中，每次迁移一部分数据，直到 `ht[0]` 被清空，然后将 `ht[1]` 赋值给 `ht[0]`，完成 rehash。

# 4. 跳跃表

## 4.1. 结构

跳跃表通过在链表的基础上增加多级索引层来加速查找操作。每个节点可能包含多个前进指针，指向不同层级的后续节点。
在 Redis 中，跳跃表由以下两个结构体定义：
### 1. `zskiplistNode`：跳跃表节点

每个节点包含：
- `ele`：成员对象（字符串）。
- `score`：用于排序的分值（double 类型）。
- `backward`：指向前一个节点的指针，实现双向遍历。
- `level[]`：层级数组，每个元素包含：
    - `forward`：指向当前层级下一个节点的指针。
    - `span`：当前节点到下一个节点之间的跨度，用于计算排名。
### 2. `zskiplist`：跳跃表结构

整个跳跃表结构包含：
- `header`：指向表头节点的指针。
- `tail`：指向表尾节点的指针。
- `level`：当前跳跃表的最大层数。
- `length`：跳跃表中节点的数量。

这种结构设计使得跳跃表在保持有序性的同时，支持快速的查找和更新操作。

## 4.2. 操作原理

### 1. 查找操作

从最高层的表头节点开始，沿着前进指针向后遍历：
- 如果当前节点的下一个节点的分值小于目标分值，则继续在当前层向后移动。
- 如果当前节点的下一个节点的分值大于或等于目标分值，则下降一层，继续上述过程。
- 重复上述步骤，直到到达最底层。

这种多级索引的方式使得查找操作的平均时间复杂度为 O(log N)。

### 2. 插入操作

插入新节点的步骤如下：
- 生成一个随机层数，决定新节点的层级高度。
- 从最高层开始，查找每一层中插入位置的前驱节点。
- 在每一层中，将新节点的前进指针指向前驱节点的后继节点，前驱节点的前进指针指向新节点。
- 更新跨度信息和后退指针。

通过随机层数的方式，跳跃表在平均情况下保持平衡，插入操作的平均时间复杂度为 O(log N)。

### 3. 删除操作

删除节点的步骤如下：
- 从最高层开始，查找每一层中待删除节点的前驱节点。
- 在每一层中，将前驱节点的前进指针指向待删除节点的后继节点。
- 更新跨度信息和后退指针。
- 如果某一层中没有节点，则减少跳跃表的层数。

删除操作的平均时间复杂度为 O(log N)。

## 4.3. 应用场景

在 Redis 中，跳跃表主要用于实现有序集合（ZSet）。当有序集合中的元素数量较多或元素成员较长时，Redis 会选择跳跃表作为底层实现，以提高操作效率。

具体应用包括：
- 快速获取指定排名的元素。
- 范围查询，如获取分值在某一范围内的所有元素。
- 按分值排序的迭代操作。

跳跃表的有序性和高效的查找性能，使得这些操作能够在对数时间内完成。

## 4.4. 跳跃表与其他数据结构的比较

|数据结构|查找复杂度|插入复杂度|删除复杂度|有序性|实现复杂度|
|---|---|---|---|---|---|
|跳跃表|O(log N)|O(log N)|O(log N)|是|中|
|哈希表|O(1)|O(1)|O(1)|否|低|
|平衡树|O(log N)|O(log N)|O(log N)|是|高|

跳跃表在保持有序性的同时，提供了与平衡树相当的操作性能，但实现相对简单。与哈希表相比，虽然查找性能略低，但支持有序操作。

## 4.5. 跳跃表的优缺点

**优点：**

- 支持快速的查找、插入和删除操作，平均时间复杂度为 O(log N)。
- 结构简单，易于实现和维护。
- 支持有序操作，如范围查询和按排名获取元素。

**缺点：**

- 由于使用多级索引，空间消耗略高于普通链表。
- 性能依赖于随机数生成器的质量，极端情况下可能退化为线性时间复杂度。

# 5. 整数集合
## 5.1. 结构
```
typedef struct intset {
    uint32_t encoding;  // 编码方式
    uint32_t length;    // 集合中元素的数量
    int8_t contents[];  // 保存元素的数组
} intset;
```
- **encoding**：表示当前集合的编码方式，可能的取值有：
    - `INTSET_ENC_INT16`：16 位整数
    - `INTSET_ENC_INT32`：32 位整数
    - `INTSET_ENC_INT64`：64 位整数
- **length**：表示集合中元素的数量。
- **contents**：实际存储元素的数组，数组中的元素按照从小到大的顺序排列，且不包含重复项。

## 5.2. 特性

- **仅存储整数**：整数集合只能存储整数类型的元素，不能包含非整数类型的元素。
- **有序存储**：集合中的元素按照从小到大的顺序存储，便于进行二分查找。
- **自动升级**：当添加的新元素的类型比当前集合的编码类型更大时，集合会自动升级编码方式，以适应新的元素。例如，从 `INTSET_ENC_INT16` 升级到 `INTSET_ENC_INT32`。
- **不支持降级**：一旦集合升级到更高的编码方式，即使删除了较大的元素，集合也不会自动降级。

## 5.3. 应用场景

在 Redis 中，当集合只包含整数元素且元素数量不多时，Redis 会选择整数集合作为集合键的底层实现，以提高存储和操作效率。
```
redis> SADD myset 1 2 3
(integer) 3
redis> OBJECT ENCODING myset
"intset"
```
当集合中的元素数量增加或添加了非整数类型的元素时，Redis 会自动将底层实现转换为哈希表（hashtable）以适应新的数据结构需求。

# 6. 压缩列表
## 6.1. 压缩列表的结构组成

压缩列表由以下部分组成：
- **zlbytes**（4 字节）：记录整个压缩列表占用的内存字节数。
- **zltail**（4 字节）：记录压缩列表尾节点距离起始地址的偏移量，便于快速定位尾节点。
- **zllen**（2 字节）：记录压缩列表包含的节点数量。
- **entries**：实际存储的节点列表，每个节点包含前一个节点的长度、编码方式和内容。
- **zlend**（1 字节）：特殊标识，值为 0xFF，表示压缩列表的结束。

这种结构设计使得压缩列表在内存中连续存储，减少了内存碎片，提高了缓存命中率。

## 6.2. 节点结构详解

每个节点（entry）由以下部分组成：

1. **prevlen**：记录前一个节点的长度。
    - 如果前一个节点的长度小于 254 字节，使用 1 字节存储该长度。
    - 如果前一个节点的长度大于等于 254 字节，使用 5 字节存储，其中第一个字节为 0xFE，后四个字节表示长度。
2. **encoding**：表示当前节点数据的类型和长度。
    - 字符串类型：
        - 长度小于等于 63 字节，使用 1 字节编码。
        - 长度小于等于 16383 字节，使用 2 字节编码。
        - 长度小于等于 4294967295 字节，使用 5 字节编码。
    - 整数类型：
        - 根据整数的大小，使用不同的编码方式，长度为 1 字节。
3. **content**：存储实际的数据内容，可以是字符串或整数，具体类型和长度由 encoding 决定。

通过这种设计，压缩列表能够灵活地存储不同类型和长度的数据，同时保持紧凑的内存布局。

## 6.3. 适用场景与限制

压缩列表主要用于以下场景：

- **列表（List）**：当列表中的元素数量较少且每个元素的长度较短时，Redis 使用压缩列表作为底层实现。
- **哈希（Hash）**：当哈希中的键值对数量较少且键和值的长度较短时，使用压缩列表存储。
- **有序集合（Sorted Set）**：当有序集合中的元素数量较少且成员和分值的长度较短时，采用压缩列表实现。

具体的阈值可以通过以下配置项进行调整：

- **hash-max-ziplist-entries**：哈希类型使用压缩列表的最大键值对数量，默认值为 512。
- **hash-max-ziplist-value**：哈希类型使用压缩列表的最大键或值的长度，默认值为 64 字节。
- **list-max-ziplist-size**：列表类型使用压缩列表的最大元素数量。
- **zset-max-ziplist-entries**：有序集合使用压缩列表的最大元素数量，默认值为 128。
- **zset-max-ziplist-value**：有序集合使用压缩列表的最大成员或分值的长度，默认值为 64 字节。

当数据结构超过上述阈值时，Redis 会自动将底层实现转换为其他结构，如哈希表（hashtable）或跳跃表（skiplist）。

## 6.4. 优缺点分析

**优点：**

- **内存紧凑**：通过连续内存存储和灵活的编码方式，压缩列表显著减少了内存占用。
- **高效的顺序访问**：由于内存连续，顺序访问性能较好，适合遍历操作。
- **适用于小数据量场景**：在元素数量和长度较小的情况下，压缩列表提供了良好的性能和内存效率。

**缺点：**

- **随机访问性能较差**：由于需要从头部开始遍历，随机访问的时间复杂度为 O(N)。
- **修改操作可能导致连锁更新**：在插入或删除操作中，可能需要调整多个节点的 prevlen，导致性能下降。
- **不适合存储大量数据**：当元素数量或长度较大时，压缩列表的性能和内存优势会减弱。

## 6.5. 连锁更新问题

在压缩列表中，插入或删除操作可能引发连锁更新（cascade update）问题。例如，当插入一个新节点使得前一个节点的长度从小于 254 字节增加到大于等于 254 字节时，prevlen 的存储方式需要从 1 字节扩展到 5 字节。这会导致后续所有节点的 prevlen 都需要更新，从而引发连锁更新，影响性能。

# 7. 对象
## 7.1. redisObject 结构

`redisObject` 结构体定义如下：

```
typedef struct redisObject {
    unsigned type:4;       // 对象类型
    unsigned encoding:4;   // 编码方式
    void *ptr;             // 指向底层数据结构的指针
} robj;
```

- **type**：表示对象的类型，Redis 支持以下几种类型：
    - `REDIS_STRING`：字符串对象
    - `REDIS_LIST`：列表对象
    - `REDIS_HASH`：哈希对象
    - `REDIS_SET`：集合对象
    - `REDIS_ZSET`：有序集合对象
- **encoding**：表示对象的底层实现方式，即使用哪种数据结构来存储数据。
- **ptr**：指向实际存储数据的底层数据结构的指针。

这种设计使得 Redis 能够根据数据的特点选择最合适的底层数据结构，以优化内存使用和操作效率。

## 7.2. 对象类型与编码方式

Redis 的每种对象类型可以有多种编码方式，具体如下：
### 1. 字符串对象（String）

- **编码方式**：
    - `REDIS_ENCODING_INT`：用于存储整数值。
    - `REDIS_ENCODING_EMBSTR`：用于存储短字符串（长度小于等于 44 字节）。
    - `REDIS_ENCODING_RAW`：用于存储长字符串。

### 2. 列表对象（List）

- **编码方式**：
    - `REDIS_ENCODING_QUICKLIST`：结合了双向链表和压缩列表的优点，用于存储列表数据。

### 3. 哈希对象（Hash）

- **编码方式**：
    - `REDIS_ENCODING_ZIPLIST`：用于存储小型哈希表。
    - `REDIS_ENCODING_HT`：用于存储大型哈希表。

### 4. 集合对象（Set）

- **编码方式**：
    - `REDIS_ENCODING_INTSET`：用于存储整数集合。
    - `REDIS_ENCODING_HT`：用于存储非整数集合。

### 5. 有序集合对象（ZSet）

- **编码方式**：
    - `REDIS_ENCODING_ZIPLIST`：用于存储小型有序集合。
    - `REDIS_ENCODING_SKIPLIST`：用于存储大型有序集合。

Redis 会根据数据的大小和类型自动选择最合适的编码方式。例如，当哈希对象的字段数量较少且每个字段的长度较短时，Redis 会使用 `ZIPLIST` 编码；当字段数量增多或字段长度增加时，Redis 会自动转换为 `HT` 编码。

## 7.3. 对象的内存管理

Redis 使用引用计数机制来管理对象的内存。每个 `redisObject` 都有一个引用计数器，当引用计数为 0 时，表示该对象不再被使用，可以被释放。
此外，Redis 还使用了惰性释放和共享对象等优化策略，以减少内存碎片和提高内存使用效率。

## 7.4. 对象的应用示例

以下是一些 Redis 对象的应用示例：

- **字符串对象**：用于缓存网页内容、存储计数器等。
- **列表对象**：用于实现消息队列、任务列表等。
- **哈希对象**：用于存储用户信息、配置项等。
- **集合对象**：用于存储标签、唯一标识符等。
- **有序集合对象**：用于实现排行榜、延迟队列等。