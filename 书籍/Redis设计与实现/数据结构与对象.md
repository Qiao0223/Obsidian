# 1. 简单动态字符串
## 1.1. SDS 的结构定义
```
struct sdshdr {
    int len;    // buf 中已使用的字节数，即字符串长度
    int free;   // buf 中未使用的字节数
    char buf[]; // 字节数组，用于存储字符串数据
};
```
## 1.2. SDS 的优点

- **常数时间获取字符串长度**：由于 SDS 结构中维护了 len 字段，获取字符串长度的操作时间复杂度为 O(1)，避免了 C 字符串中需要遍历整个字符串的问题。
- **防止缓冲区溢出**：SDS 在执行修改操作前，会检查并自动扩展内存，避免了 C 字符串中常见的缓冲区溢出问题。
- **减少内存重分配次数**：SDS 采用空间预分配和惰性空间释放策略，减少了频繁的内存分配和释放操作，提高了性能。
- **二进制安全**：SDS 不依赖于空字符 `\0` 来标识字符串结束，因此可以安全地存储任意二进制数据。
- **兼容部分 C 字符串函数**：SDS 的 buf 末尾仍保留了一个 `\0` 字符，使其在需要时可以与 C 的字符串函数兼容。

## 1.3. SDS 与 C 字符串的对比
|特性|C 字符串|SDS|
|---|---|---|
|长度获取|O(N)，需遍历|O(1)，直接读取 len 字段|
|缓冲区溢出风险|高|低，自动扩展内存|
|内存重分配频率|高|低，采用预分配和惰性释放策略|
|二进制安全|否|是|
|与 C 函数兼容性|完全兼容|兼容部分函数|
# 2. 链表
## 2.1. 链表结构
### 1. 链表节点（listNode）
每个节点包含：
- `prev`：指向前一个节点的指针
- `next`：指向后一个节点的指针
- `value`：指向节点存储的数据的指针

这使得链表可以在两个方向上进行遍历。
### 2. 链表结构体（list）

整个链表结构体包含：
- `head`：指向链表头节点的指针
- `tail`：指向链表尾节点的指针
- `len`：链表中节点的数量
- 函数指针：用于定义节点值的复制、释放和匹配操作

## 2.2. 特性

- **双向性**：每个节点都包含前后指针，支持从任意节点向前或向后遍历。
- **无环性**：链表的头节点的 `prev` 和尾节点的 `next` 都指向 `NULL`，表示链表的开始和结束。
- **带头尾指针**：链表结构体中包含指向头尾节点的指针，便于在 O(1) 时间内访问链表的两端。
- **长度计数器**：链表结构体中维护了一个计数器，记录链表中节点的数量，获取长度的操作时间复杂度为 O(1)。
- **多态性**：通过函数指针，链表可以存储和操作多种类型的数据。

# 3. 字典
## 3.1. 结构

Redis 的字典主要由以下几个结构组成：
### 1. `dictEntry`：哈希表节点

每个节点表示一个键值对，结构如下：
```
typedef struct dictEntry {
    void *key;             // 键
    union {
        void *val;         // 值（可以是指针）
        uint64_t u64;      // 64 位无符号整数
        int64_t s64;       // 64 位有符号整数
    } v;
    struct dictEntry *next; // 指向下一个节点，解决哈希冲突
} dictEntry;
```
### 2. `dictht`：哈希表

`dictht` 结构表示一个哈希表，包含以下字段：

```
typedef struct dictht {
    dictEntry **table;     // 哈希表数组
    unsigned long size;    // 哈希表大小
    unsigned long sizemask;// 哈希表大小掩码，用于计算索引值
    unsigned long used;    // 当前已使用的节点数量
} dictht;
```

- `table`：是一个数组，数组的每个元素是指向 `dictEntry` 的指针。
- `size`：表示哈希表的大小，即 `table` 数组的长度。
- `sizemask`：等于 `size - 1`，用于快速计算索引值。
- `used`：表示哈希表中已使用的节点数量。

### 3. `dict`：字典结构

`dict` 结构是对哈希表的封装，支持动态扩容和渐进式 rehash，结构如下：[阿里云开发者社区+7腾讯云+7CSDN博客+7](https://cloud.tencent.com/developer/article/1005121?utm_source=chatgpt.com)

```
typedef struct dict {
    dictType *type;        // 类型特定函数
    void *privdata;        // 私有数据
    dictht ht[2];          // 哈希表，支持渐进式 rehash
    long rehashidx;        // rehash 进度，-1 表示未进行
    unsigned long iterators; // 当前正在使用的迭代器数量
} dict;
```

- `ht[0]`：正常使用的哈希表。
- `ht[1]`：在 rehash 过程中使用的新哈希表。
- `rehashidx`：记录 rehash 的进度，-1 表示未进行。
- `iterators`：表示当前正在使用的迭代器数量。

## 3.2. 哈希冲突与解决方案

Redis 使用链地址法解决哈希冲突。当多个键的哈希值相同时，这些键值对会被存储在同一个桶中，并通过链表连接。
## 3.3. 渐进式 Rehash

为了保持哈希表的性能，Redis 会在以下情况下触发哈希表的扩容或缩容：
- 当哈希表的负载因子超过一定阈值时，触发扩容。
- 当哈希表的负载因子低于一定阈值时，触发缩容。

Redis 采用渐进式 rehash（Incremental Rehash）策略，将 rehash 操作分散到多个步骤中，以避免一次性 rehash 带来的性能问题。

在 rehash 过程中，Redis 会逐步将 `ht[0]` 中的键值对迁移到 `ht[1]` 中，每次迁移一部分数据，直到 `ht[0]` 被清空，然后将 `ht[1]` 赋值给 `ht[0]`，完成 rehash。

# 4. 跳跃表

## 4.1. 结构

跳跃表通过在链表的基础上增加多级索引层来加速查找操作。每个节点可能包含多个前进指针，指向不同层级的后续节点。
在 Redis 中，跳跃表由以下两个结构体定义：
### 1. `zskiplistNode`：跳跃表节点

每个节点包含：
- `ele`：成员对象（字符串）。
- `score`：用于排序的分值（double 类型）。
- `backward`：指向前一个节点的指针，实现双向遍历。
- `level[]`：层级数组，每个元素包含：
    - `forward`：指向当前层级下一个节点的指针。
    - `span`：当前节点到下一个节点之间的跨度，用于计算排名。
### 2. `zskiplist`：跳跃表结构

整个跳跃表结构包含：
- `header`：指向表头节点的指针。
- `tail`：指向表尾节点的指针。
- `level`：当前跳跃表的最大层数。
- `length`：跳跃表中节点的数量。

这种结构设计使得跳跃表在保持有序性的同时，支持快速的查找和更新操作。

## 4.2. 操作原理

### 1. 查找操作

从最高层的表头节点开始，沿着前进指针向后遍历：
- 如果当前节点的下一个节点的分值小于目标分值，则继续在当前层向后移动。
- 如果当前节点的下一个节点的分值大于或等于目标分值，则下降一层，继续上述过程。
- 重复上述步骤，直到到达最底层。

这种多级索引的方式使得查找操作的平均时间复杂度为 O(log N)。

### 2. 插入操作

插入新节点的步骤如下：
- 生成一个随机层数，决定新节点的层级高度。
- 从最高层开始，查找每一层中插入位置的前驱节点。
- 在每一层中，将新节点的前进指针指向前驱节点的后继节点，前驱节点的前进指针指向新节点。
- 更新跨度信息和后退指针。

通过随机层数的方式，跳跃表在平均情况下保持平衡，插入操作的平均时间复杂度为 O(log N)。

### 3. 删除操作

删除节点的步骤如下：
- 从最高层开始，查找每一层中待删除节点的前驱节点。
- 在每一层中，将前驱节点的前进指针指向待删除节点的后继节点。
- 更新跨度信息和后退指针。
- 如果某一层中没有节点，则减少跳跃表的层数。

删除操作的平均时间复杂度为 O(log N)。

## 4.3. 应用场景

在 Redis 中，跳跃表主要用于实现有序集合（ZSet）。当有序集合中的元素数量较多或元素成员较长时，Redis 会选择跳跃表作为底层实现，以提高操作效率。

具体应用包括：
- 快速获取指定排名的元素。
- 范围查询，如获取分值在某一范围内的所有元素。
- 按分值排序的迭代操作。

跳跃表的有序性和高效的查找性能，使得这些操作能够在对数时间内完成。

## 4.4. 跳跃表与其他数据结构的比较

|数据结构|查找复杂度|插入复杂度|删除复杂度|有序性|实现复杂度|
|---|---|---|---|---|---|
|跳跃表|O(log N)|O(log N)|O(log N)|是|中|
|哈希表|O(1)|O(1)|O(1)|否|低|
|平衡树|O(log N)|O(log N)|O(log N)|是|高|

跳跃表在保持有序性的同时，提供了与平衡树相当的操作性能，但实现相对简单。与哈希表相比，虽然查找性能略低，但支持有序操作。

## 4.5. 跳跃表的优缺点

**优点：**

- 支持快速的查找、插入和删除操作，平均时间复杂度为 O(log N)。
- 结构简单，易于实现和维护。
- 支持有序操作，如范围查询和按排名获取元素。

**缺点：**

- 由于使用多级索引，空间消耗略高于普通链表。
- 性能依赖于随机数生成器的质量，极端情况下可能退化为线性时间复杂度。

# 5. 整数集合
## 5.1. 结构
```
typedef struct intset {
    uint32_t encoding;  // 编码方式
    uint32_t length;    // 集合中元素的数量
    int8_t contents[];  // 保存元素的数组
} intset;
```
- **encoding**：表示当前集合的编码方式，可能的取值有：
    - `INTSET_ENC_INT16`：16 位整数
    - `INTSET_ENC_INT32`：32 位整数
    - `INTSET_ENC_INT64`：64 位整数[博客园+5CSDN博客+5博客园+5](https://blog.csdn.net/qq_72189290/article/details/141254125?utm_source=chatgpt.com)[CSDN博客+3博客园+3张先森的代码小屋+3](https://www.cnblogs.com/jiujuan/p/15993249.html?utm_source=chatgpt.com)
- **length**：表示集合中元素的数量。
    
- **contents**：实际存储元素的数组，数组中的元素按照从小到大的顺序排列，且不包含重复项。