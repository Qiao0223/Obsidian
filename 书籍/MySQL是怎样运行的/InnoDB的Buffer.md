# 1. 为什么需要缓存？

- **磁盘读写速度太慢**（机械硬盘或 SSD 相比内存仍慢几个数量级）
- InnoDB 数据最终是**页（Page）**形式存储在**表空间**中（磁盘文件）
- **即使访问一条记录，也需要将整个页读取进内存**
- 为避免频繁磁盘 I/O，**InnoDB 会将访问过的页缓存起来**，即所谓的 Buffer Pool

# 2. 什么是 Buffer Pool？

- Buffer Pool 是 InnoDB **在启动时向操作系统申请的一块连续大内存空间**
- 用于 **缓存磁盘页（默认每页16KB）**
- 含义上就像是 **InnoDB 的内存数据库页缓存**

## 2.1. Buffer Pool 的内部结构
```
+---------------------+----------------------+
| 控制块区域 Control  | 缓存页区域 Page     |
| (每块约占 808B)     | (每页默认 16KB)     |
+---------------------+----------------------+
```
每一个 **缓存页（16KB）** 都对应一个 **控制块（约 808B）**

控制块包含的信息有

| 控制信息内容                   | 用途说明              |
| ------------------------ | ----------------- |
| 表空间编号（space_id）          | 确定该页属于哪个表空间       |
| 页号（page_no）              | 确定该页在表空间中的位置      |
| 缓存页在 Buffer Pool 的地址     | 内存定位              |
| 链表指针                     | 用于管理 LRU、flush 链表 |
| 锁信息（mutex/latch）         | 保障线程并发安全          |
| LSN（Log Sequence Number） | 用于判断是否需要刷新页到磁盘    |
# 3. Buffer Pool 的free 链表管理机制

### Buffer Pool 启动初始化流程
- MySQL 启动时会：
    1. 向 **操作系统申请一块连续的大内存**（即 Buffer Pool）
    2. 按照页大小（通常 16KB）划分成若干个**缓存页**
    3. 每个缓存页都有一个对应的 **控制块**
        - 控制块结构占用约 **808 字节**
        - 存储页的元数据：空间编号、页号、状态等
- 此时页数据尚未从磁盘加载进来，**所有缓存页为空闲状态**

## 3.2. free 链表的作用

目的是记录：哪些缓存页是空闲可用的。
- 所有空闲缓存页的 **控制块节点** 会被挂在一个专门的 **free 链表** 中
- 每次需要加载磁盘页时，就从该链表中取一个节点，使用它所对应的缓存页空间

## 3.3. 基节点（基指针）的设计

- 每个链表（如 `free`、`LRU`、`flush` 等）都会对应一个 **基节点结构**
    - 保存：
        - 链表头节点地址
        - 链表尾节点地址
        - 链表当前节点数量
- 注意：基节点不是在 `innodb_buffer_pool_size` 指定的内存范围内分配的，而是：
    - **额外申请的 40 字节空间**
    - 每个链表都有独立的基节点空间（不共用）

## 3.4. 使用流程简述

- **初始化时**：
    - 所有控制块挂到 free 链表中
- **读取磁盘页时**：
    - 从 `free` 链表中取出一个控制块，找到其对应缓存页
    - 把该页用于加载磁盘内容
    - 同时从 `free` 链表中移除该节点
- **释放缓存页（如淘汰）时**：
    - 控制块重新加入到 `free` 链表尾部

# 4. 缓存页的哈希处理机制（Page Hash Table）
## 4.1. 哈希表结构设计

| 项           | 描述                           |
| ----------- | ---------------------------- |
| 键（key）      | 表空间号（space_id） + 页号（page_no） |
| 值（value）    | 对应的**缓存页的控制块指针**（间接定位页数据）    |
| 哈希桶（bucket） | 通过哈希函数映射后的位置，每个桶用**链表**处理冲突  |
| 结构类型        | **数组 + 链表**的经典哈希表实现          |
## 4.2. 查询页是否在缓存中的步骤

1. 构造 `key = (space_id, page_no)`
2. 使用哈希函数映射到哈希桶
3. 遍历桶中的链表（若有冲突）
4. 如果找到了：直接返回缓存页
5. 如果没有：
    - 从 `free 链表` 取出空闲页
    - 从磁盘读取数据填入
    - 加入哈希表中，以便下次快速命中

# 5. Flush 链表机制详解

## 5.1. 什么是脏页（dirty page）？

- 当对 **Buffer Pool 中的页**进行 **修改（写操作）**后，该页与磁盘上的页内容不一致。
- 这种页被称为 **脏页**。
- 脏页 ≠ 错误，仅表示「**需要在将来某时刷新到磁盘**」。

## 5.2. 为什么不立刻写回磁盘？

- **写入磁盘是 IO 密集型操作**，非常慢，频繁写回会严重影响性能。
- 解决办法：
    - 修改时**只修改缓存页（内存）**
    - 日后**批量异步刷新**到磁盘（**刷脏**）
    - 典型的异步刷新机制：**checkpoint**

## 5.3. Flush 链表的作用
| 功能     | 描述                        |
| ------ | ------------------------- |
| 追踪脏页   | 记录所有**被修改但尚未刷盘**的页        |
| 减少刷盘成本 | 避免全量遍历 Buffer Pool 找脏页    |
| 支持崩溃恢复 | 按照特定顺序刷脏页以保证数据一致性（LSN 顺序） |

## 5.4. Flush 链表的结构

- 与 free 链表结构类似：由**控制块节点**构成的双向链表
- 每一个链表节点 = 一块**已被修改的缓存页的控制块**
- 该链表由一个独立的 **flush list 基节点** 管理：
    - 包含：头指针、尾指针、链表长度等信息
    - 占用内存：**40 字节**（与 free list 一样）

## 5.5. 什么时候会加入 flush 链表？

- 当某个页第一次被修改时（即**由 clean 状态变为 dirty 状态**），就会：
    - 将其对应控制块加入 flush 链表尾部
- 后续对该页的再次修改：
    - 不重复加入，只更新其 LSN（Log Sequence Number）

## 5.6. 脏页刷盘时怎么处理？

- 按 **LSN 顺序** 从 flush 链表中依次**选择脏页刷回磁盘**
- 刷新完后：
    - 将该页从 flush 链表中移除
    - 其状态由 dirty → clean

# 6. LRU 链表机制
## 6.1. LRU链表的引入动机：Buffer Pool 空间不足怎么办？

- **Buffer Pool** 是有限的（默认128MB，可调）。
- 当没有空闲页（free list 为空）时，需要从缓存中**淘汰一些页**，为新页腾地方。
- 淘汰策略不能随意 —— 应该遵循**“最近最少使用”（LRU）**原则。
- 所以就需要一个 **LRU 链表（Least Recently Used List）**。

## 6.2. 基本操作规则（单区域 LRU）

- 页加载：
    - 若页不在 Buffer Pool：加载到内存、加入 LRU 头部
    - 若页已在内存：将其从原位置移到 LRU 头部
- 淘汰策略：
    - 淘汰 LRU 尾部的缓存页（最久未被访问）
- 问题：**预读页**和**全表扫描**会干扰真正的热点页，被称为“劣币驱逐良币”现象

## 6.3. 为什么单纯的 LRU 有问题？

#### 情况一：预读页污染缓存
- 预读（Read Ahead）：
    - 线性预读：触发阈值为 `innodb_read_ahead_threshold`（默认 56）
    - 随机预读：满足 13 页连续命中，可触发（需 `innodb_random_read_ahead = ON`）
- 预读页可能从未被访问 → 占据 LRU 前部 → 快速淘汰真正热点页
#### 情况二：全表扫描污染缓存
- 全表扫描：读取大量页，放入 LRU 前部
- 执行频率低，访问频率也低
- 这些“冷”页覆盖了原有“热”页，降低命中率

## 6.4. LRU 链表的区域划分：Young + Old

用两个区域分隔 LRU，优化冷热页命中效率

|区域|含义|特点|
|---|---|---|
|**Young 区域**|热点页|频繁访问，LRU 前部|
|**Old 区域**|新加载或低频页|位于 LRU 后部，占总长度的 37%（默认）|
#### 访问规则
- 页**首次加载** → 放入 **Old 区域头部**
- 后续访问：
    - 如果和首次访问时间间隔小于 `innodb_old_blocks_time` → **不晋升**
    - 否则 → 晋升到 Young 区域头部
这样，**短时间内多次访问**的全表扫描页，不会污染热点页所在的 Young 区域。

# 7. 脏页刷新机制

## 7.1. 为什么需要刷新脏页？

- **脏页（Dirty Page）**：已在 Buffer Pool 中被修改，但尚未写回磁盘的页。
- 如果不刷盘：
    - 数据库崩溃后，脏页数据会丢失；
    - Buffer Pool 被占满后，无空页可用；
- 所以必须**定期**或者**被动地**将脏页刷回磁盘。

## 7.2. 三种脏页刷新方式（由线程/机制触发）

| 类型   | 刷新来源         | 描述                   | 名称                      |
| ---- | ------------ | -------------------- | ----------------------- |
| 定期刷新 | LRU 链表尾部（冷页） | 后台线程定时扫描尾部，刷一部分脏页到磁盘 | `BUF_FLUSH_LRU`         |
| 定期刷新 | Flush 链表     | 定期按顺序批量刷出被修改过的页      | `BUF_FLUSH_LIST`        |
| 被动刷新 | LRU 尾部的脏页    | 用户线程加载页时无空页 → 强制刷出一个 | `BUF_FLUSH_SINGLE_PAGE` |
###  1. `BUF_FLUSH_LRU`：LRU 冷数据刷新

- 后台线程**定期**从 LRU 链表尾部扫描若干页；
- 如果发现是 **脏页**，就会把它刷入磁盘；

  **适用场景**：
- 清理掉冷数据脏页；
- 提前释放一批页，提升 Buffer Pool 可用性。

### 2. `BUF_FLUSH_LIST`：flush 链表刷新

- 后台线程维护一个 **flush 链表**（只挂脏页）；
- 会**周期性**按顺序从中刷出一部分页到磁盘；
- 刷新速率受系统繁忙程度控制；
- 常用于**保证数据持久性**和**减少 redo log 积压**。

  **关键特性**：
- 与 redo checkpoint 策略密切相关；
- 刷写顺序通常按页的 **修改时间顺序**（写入顺序）。

### 3. `BUF_FLUSH_SINGLE_PAGE`：用户线程刷脏页

- 若 Buffer Pool 空页不足，用户线程尝试从 LRU 尾部释放未用页；
- 若全是脏页，就**强制刷写**一个脏页（非常慢）；
- 被称为**同步刷新**，直接影响用户请求响应时间。

  **极端情况会导致**：
- 大量用户线程同时触发刷页 → 严重性能下降；
- 所以 **后台刷新足够快** 是关键。

## 7.3. 还有什么情况会刷新脏页？

1. **Redo log 空间不足时**，会触发 flush list 强制刷写（触发 checkpoint）；
2. **数据库关闭时**，所有脏页必须刷盘；
3. **表空间被回收或释放**时，相关脏页必须同步刷出；
4. **手动触发**