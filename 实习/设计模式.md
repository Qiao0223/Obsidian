# 1. 模板方法
## 1.1. 概述

**意图（Intent）**  
定义一个操作中的算法骨架（即“模板方法”），将某些步骤的具体实现延迟到子类。模板方法使得子类可以在不改变算法结构的前提下，重新定义算法中的某些特定步骤。

**适用场景**

- 多个子类有相同的处理流程，只是流程中的某些步骤不同；
- 要控制子类扩展的粒度，防止子类随意更改流程；
- 希望将通用行为集中在一个地方，减少重复代码。

## 1.2. 模式结构

```
AbstractClass
├── templateMethod()           // 定义算法骨架，调用一系列抽象或具体方法
├── primitiveOperation1()      // “原语”方法，抽象，留给子类实现
├── primitiveOperation2()
└── concreteOperation()        // 钩子/辅助方法，提供默认实现，可由子类覆盖

ConcreteClassA extends AbstractClass
└── primitiveOperation1()      // 子类 A 的具体实现

ConcreteClassB extends AbstractClass
└── primitiveOperation2()      // 子类 B 的具体实现
```

- **模板方法（templateMethod）**：`final` 或不被覆盖的方法，按固定顺序调用原语操作和可选的钩子操作。
- **原语操作（primitiveOperation）**：抽象方法，强制子类实现。
- **钩子方法（hook）**：非抽象方法，提供默认空实现，允许子类根据需要重写。

## 1.3. `AbstractQuartzJob` 中的模板方法拆解

以下是经过简化的伪代码，演示 `AbstractQuartzJob` 是如何定义“模板方法”的
```
public abstract class AbstractQuartzJob implements Job {
    // 用于记录任务开始时间等线程上下文
    private static ThreadLocal<Date> threadLocal = new ThreadLocal<>();

    // —— 模板方法 ——  
    @Override
    public final void execute(JobExecutionContext context) throws JobExecutionException {
        SysJob sysJob = getSysJobFromContext(context);     // 通用代码：准备上下文
        threadLocal.set(new Date());                       // 记录开始时间

        try {
            before(context, sysJob);                       // 钩子：任务执行前通用准备（如日志入库）
            doExecute(context, sysJob);                    // 原语操作：交给子类实现的核心逻辑
            after(context, sysJob, null);                  // 钩子：任务完成后通用收尾（如状态更新）
        } catch (Exception e) {
            after(context, sysJob, e);                     // 钩子：发生异常时也要做收尾
            throw new JobExecutionException(e);            // 抛出 Quartz 需知的异常类型
        } finally {
            threadLocal.remove();                          // 清理线程变量
        }
    }

    /**  
     * 子类必须实现的核心业务逻辑  
     */
    protected abstract void doExecute(JobExecutionContext context, SysJob sysJob) throws Exception;

    /**  
     * 任务执行前的“钩子”方法——默认做一些公共前置处理，子类可覆盖  
     */
    protected void before(JobExecutionContext context, SysJob sysJob) {
        // 比如：记录“任务开始”日志、更新数据库状态为“运行中”等
    }

    /**  
     * 任务完成或失败后的“钩子”方法——可记录结果、清理资源  
     */
    protected void after(JobExecutionContext context, SysJob sysJob, Exception e) {
        // 比如：记录“任务结束”日志、更新数据库状态为“成功/失败”、发送通知等
    }
}
```

关键点说明
- **`execute(...)` 是模板方法**
    - 标记为 `final`（或不建议被覆盖），确保子类不能改变整体流程顺序。
    - 包含四个阶段：准备 → `before` → `doExecute` → `after` → 清理。

- **`doExecute` 是原语操作**
    - 定义为 `abstract`，子类务必提供业务实现。
    - 只关注“做什么”，不必重复处理日志、异常、事务等公共逻辑。

- **`before`/`after` 是钩子方法**
    - 提供默认实现（通常是空或通用处理），子类可根据需要 override。
    - 保证钩子可选，不会破坏主流程。

- **异常统一处理**
    - 模板方法捕获所有 `Exception`，并在 `after` 中传递异常信息，让后置处理充分获知失败原因。
    - 最终将异常包装成 Quartz 要求的 `JobExecutionException` 抛出。

- **线程上下文管理**
    - 通过 `ThreadLocal` 记录任务开始时间或其他上下文信息，并在 `finally` 中清理，避免内存泄漏或数据串用。

## 子类如何复用
