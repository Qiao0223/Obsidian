# 1. JVM 架构组成

JVM 的整体架构主要包括以下几个核心组件：

## 1.1. 类加载器子系统（Class Loader Subsystem）

负责将 `.class` 文件加载到内存中，并完成验证、准备、解析和初始化等步骤。类加载器采用双亲委派模型，包括：[维基百科](https://zh.wikipedia.org/wiki/Java%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8?utm_source=chatgpt.com)

- **引导类加载器（Bootstrap ClassLoader）**：加载 Java 核心类库。
- **扩展类加载器（Extension ClassLoader）**：加载扩展类库。
- **应用类加载器（Application ClassLoader）**：加载应用程序的类。

这种机制确保了 Java 核心类的安全性和一致性。

## 1.2. 运行时数据区（Runtime Data Areas）

JVM 在执行 Java 程序时会划分出若干内存区域：

- **程序计数器（Program Counter Register）**：每个线程都有一个，用于指示当前线程执行的字节码行号。
- **Java 虚拟机栈（JVM Stack）**：每个线程私有，存储方法调用的局部变量、操作数栈、动态链接和方法出口等信息。
- **本地方法栈（Native Method Stack）**：为本地方法（Native）服务。
- **堆（Heap）**：所有线程共享，用于存放对象实例和数组，是垃圾回收器管理的主要区域。
- **方法区（Method Area）**：所有线程共享，存储已被虚拟机加载的类信息、常量、静态变量等。

在 JDK 8 之后，方法区被移除，取而代之的是元空间（Metaspace），它使用本地内存而非虚拟机内存。

## 1.3. 执行引擎（Execution Engine）

负责执行字节码，包括：

- **解释器（Interpreter）**：逐条解释执行字节码。
- **即时编译器（JIT Compiler）**：将热点代码编译为机器码，提高执行效率。

## 1.4. 本地接口（Native Interface）

提供与本地库（如 C/C++ 编写的库）的交互能力，允许 Java 程序调用本地方法。

# 2. Java 内存模型（Java Memory Model）

## 2.1. 核心概念

### 1. 主内存与工作内存

- **主内存（Main Memory）**：存储所有线程共享的变量，包括实例字段、静态字段和数组元素。
- **工作内存（Working Memory）**：每个线程私有，存储该线程使用的变量副本。线程对变量的所有操作（读取、写入）必须在工作内存中进行，不能直接访问主内存中的变量。

线程之间的变量值传递必须通过主内存完成，即一个线程修改了共享变量的值，必须刷新到主内存中，其他线程才能读取到最新的值。 

### 2. 可见性、原子性和有序性

- **可见性**：一个线程对共享变量的修改，其他线程能够立即得知。JMM 通过定义主内存和工作内存的交互规则，确保可见性。
- **原子性**：一个操作或多个操作要么全部执行完毕且不被中断，要么完全不执行。Java 提供了 `synchronized`、`volatile` 和原子类（如 `AtomicInteger`）来保证原子性。
- **有序性**：程序执行的顺序按照代码的先后顺序执行。JMM 允许编译器和处理器对指令进行重排序，但通过 `happens-before` 原则来保证有序性。

### 3. Happens-Before 原则

`happens-before` 是 JMM 中定义的一个重要原则，用于判断操作之间的执行顺序。如果一个操作 `A` `happens-before` 操作 `B`，那么操作 `A` 的结果对操作 `B` 是可见的，且操作 `A` 的执行顺序先于操作 `B`。

常见的 `happens-before` 关系包括：

- 程序顺序规则：在一个线程内，按照代码顺序，前面的操作 `happens-before` 后面的操作。
- 监视器锁规则：对一个锁的解锁 `happens-before` 于随后对这个锁的加锁。
- volatile 变量规则：对一个 `volatile` 变量的写操作 `happens-before` 于后续对这个变量的读操作。
- 线程启动规则：调用 `Thread.start()` 方法 `happens-before` 于该线程的每一个动作。
- 线程终结规则：线程中的所有操作 `happens-before` 于其他线程检测到该线程已经终止（通过 `Thread.join()` 等方式）。

## 2.2. 内存交互操作

JMM 定义了以下八种操作，用于描述主内存与工作内存之间的交互：

1. **lock**：作用于主内存变量，把一个变量标识为线程独占状态。
2. **unlock**：作用于主内存变量，释放被锁定的变量。
3. **read**：作用于主内存变量，把一个变量的值从主内存传输到线程的工作内存中，以便随后的 load 操作使用。
4. **load**：作用于工作内存变量，把 read 操作从主内存中得到的变量值放入工作内存的变量副本中。
5. **use**：作用于工作内存变量，把工作内存中的变量值传递给执行引擎。
6. **assign**：作用于工作内存变量，把一个从执行引擎接收到的值赋给工作内存的变量。
7. **store**：作用于工作内存变量，把工作内存中的变量值传送到主内存中，以便后续的 write 操作。
8. **write**：作用于主内存变量，把 store 操作从工作内存中得到的变量值放入主内存的变量中。

这些操作必须按顺序执行，以确保数据的一致性和可见性。

