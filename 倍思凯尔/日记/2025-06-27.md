# 1. GetSumOrderList方法详解

## 1.1. 方法概述

`GetSumOrderList` 是一个静态的 REST 查询方法，用于根据各种条件（如店铺、手机号、订单编号、时间区间、支付方式等）查询洗衣订单的列表及汇总信息，并支持分页返回。最终将结果封装到 `ClsRestCommonReturn` 对象中。

## 1.2. 参数说明

|参数名|含义|
|---|---|
|`Token, TokenType`|授权令牌及类型，用于校验请求合法性|
|`QueryShopID`|指定要查询的子店铺 ID（可选）|
|`Mobile, UserName`|客户手机号、用户名，用于匹配筛选|
|`OrderNo`|订单编号模糊查询|
|`StartTime, EndTime, TimeType`|时间区间及类型（开单/支付/取消/结单），用于设定过滤字段|
|`OrderLabel, TaskStatus, OrderType, SourceTypeRemark`|订单标签、任务状态、订单类型、来源备注|
|`CashierMobile, EmployeeType`|操作员工手机号及员工类型（开单/结单）|
|`PayType, PayStatus, Payment`|支付方式、支付状态，及混合支付时的子方式|
|`TaskStartTime, TaskEndTime`|派送任务的时间区间|
|`PageSize, PageNum`|分页大小和页码|

---

## 1.3. Token 校验

1. 调用 `ToolHelperRest.CheckToKen(Token, TokenType)` 验证令牌合法性；
2. 若返回空或 `Flag==0`，直接设置 `cs.flag=0` 并返回错误信息。

## 1.4. Hibernate 会话管理

1. 根据 `ShopID` 打开主库（`bsession`）和公共库（`session`）；
2. 若会话创建失败，同样返回错误。

## 1.5. 时间字段与起始 ID 预处理

1. 根据 `TimeType`（1–开单，2–支付，3–取消，4–结单）设置对应的数据库字段（`timeString` 等）；
2. 若提供了 `StartTime`，调用 `GetMinIDByShopIDTime` 获得最早一条记录的 ID，以构造 `ID >= StartID` 的过滤，加速大表扫描。

## 1.6. 动态拼装 SQL

- **主查询 SQL (`Sql`)**
    
    - 从 `t_shop_work_order` 及相关联的任务表、客户表、卡片表联合查询所需字段；
    - 用大量 `CASE`/`IFNULL` 表达式计算订单金额、各支付渠道金额、优惠金额等。
    
- **汇总统计 SQL (`Sql_Count`)**
    
    - 统计总订单数、总件数、各支付方式累计金额，用于返回页眉汇总。

## 1.7. 各类过滤条件

按顺序对 SQL 和统计 SQL 追加 `WHERE` 子句，主要包括：

1. **店铺维度**
    - 指定 `UsedShopID` 或父店、子店列表。
    
2. **客户信息**
    - 手机号（精确或模糊）、用户名。
    
3. **订单信息**
    - 订单编号、订单标签、订单类型、来源备注。
    
4. **时间区间**
    - 根据前面确定的 `timeString` 字段，对 `StartTime` / `EndTime` 过滤。
    
5. **任务派送时间**
    - 如果指定 `TaskStartTime/TaskEndTime`，还要确保配送方式为“派送”且已确认。
    
6. **员工筛选**
    - 开单或结单员工手机号。
    
7. **任务状态**
    - 指定 `TaskStatus` 或默认的一组状态。
    
8. **支付方式 & 子方式**
    - 通过 `PayType` 映射不同渠道的金额字段，必要时再细分 `Payment` 子类型。
    
9. **支付状态**
    - 已支付／未支付／已退款（前端 “2” 映射为 “0”）。

## 1.8. 分页与查询执行

1. **统计总数**
    - 执行 `Sql_Count`，获取总记录数 `Num`、总件数 `TotalCloth`、各金额汇总。
    - 计算总页数 `TotalPage = ceil(Num / PageSize)`。
    
2. **分页数据**
    - 在主查询 SQL 尾部追加 `ORDER BY a.CreateTime DESC LIMIT offset, PageSize`。
    - 执行查询并将结果列表放入 `map_result.Rows`。
    
3. **封装返回**
    - 将分页信息、汇总数据、结果列表一起放入 `map_result`，并设置 `cs.flag=1, cs.msg="success", cs.msgCode="200"`。

## 1.9. 异常处理与资源释放
- 在 `catch` 中记录日志并返回超时或服务器错误提示；
- 最终通过 `finally` 块关闭打开的 Hibernate 会话，避免连接泄漏。

**总结**：
- 该方法核心在于“动态拼 SQL + 两次 DB 查询（先统计，再分页） + 丰富的过滤条件 + 数据封装”。
- 适用于业务侧对洗衣订单做多维度筛选、分页展示及汇总报表的场景。

# 2. GetSumOrderList 主查询 SQL (`Sql`)详解

## 2.1. 基本SQL
```
SELECT
  -- 1. 加价状态：若存在未支付且有效的加价记录则取 PayStatus（0），否则默认为 1
  IFNULL(
    (
      SELECT e.PayStatus
      FROM t_shop_work_order_addprice e
      WHERE e.ParentShopID = '<ShopID>'
        AND e.PayStatus = 0
        AND e.IsUse = 1
        AND e.OrderID = a.ID
    ),
    1
  ) AS AddPriceStatus,

  -- 2. 基本订单金额与备注
  a.AddPrice,            -- 加价金额
  a.MerchantRemark,      -- 商家备注

  -- 3. 派单信息
  a.TaskUserName,        -- 派单执行人姓名
  a.TaskUserMobile,      -- 派单执行人手机号
  a.TaskUserID,          -- 派单执行人用户ID

  -- 4. 订单标识
  a.ShopID,              -- 下单店铺ID
  a.ID,                  -- 订单主键
  a.OrderNo,             -- 订单编号

  -- 5. 客户信息
  c.CustName,            -- 客户真实姓名
  c.UserName,            -- 客户账户名
  c.Mobile,              -- 客户手机号

  -- 6. 订单统计与分类
  a.OrderTimes,          -- 订单件数
  a.OrderType * 1    AS OrderType,     -- 订单类型（乘1强转数值）
  a.SourceTypeRemark,    -- 来源备注
  b.TaskStatus * 1   AS TaskStatus,    -- 任务状态（乘1强转数值）

  -- 7. 支付方式转换：门店微信(9→14)、客户端微信(1+1→9)、其他保留原值
  CASE
    WHEN a.PayType = 9 THEN 14
    WHEN a.ClientPayType = 1 AND a.PayType = 1 THEN 9
    ELSE a.PayType
  END AS PayType,

  a.ClientPayment,       -- 混合支付时的子方式字符串
  a.PayStatus * 1  AS PayStatus,       -- 支付状态（-1/0/1）

  -- 8. 原价与最终支付金额
  OrderTotalMoney,       -- 原始订单总金额
  IF(a.IsUpdateMoney = 1, a.UpdatePayMoney, a.OrderTotalMoney) AS OrderMoney,
                         -- 若后台改价则用改后价，否则用原价
  a.IsUpdateMoney * 1  AS IsUpdateMoney, -- 是否改价标志

  -- 9. 若已支付，则统计各类优惠与实付；否则返回 0
  IF(a.PayStatus != 0, a.CustCardDiscountMoney,      0) AS CustCardDiscountMoney,
  IF(a.PayStatus != 0, a.CardDeductMoney,             0) AS CardDeductMoney,
  IF(a.PayStatus != 0, a.CardDeductNum,               0) AS CountCardDeductNum,
  IF(a.PayStatus != 0, a.TicketMoney,                 0) AS TicketMoney,
  IF(a.PayStatus != 0, a.PayMoney,                    0) AS PayMoney,
  IF(a.PayStatus != 0, a.CustCardMoney + a.CustCardExMoney, 0) AS CustCardPayMoney,
  IF(a.PayStatus != 0, a.WxPayMoney,                   0) AS WxPayMoney,
  IF(a.PayStatus != 0, a.AllinPayMoney,                0) AS AllinPayMoney,

  -- 10. 客户端支付按渠道拆分
  IF(a.PayStatus != 0 AND a.ClientPayType = 1, a.ClientMoney, 0) AS ClientWxPayMoney,
  IF(a.PayStatus != 0 AND a.ClientPayType = 2, a.ClientMoney, 0) AS ClientZfbPayMoney,
  IF(a.PayStatus != 0 AND a.ClientPayType = 3, a.ClientMoney, 0) AS ClientCardPayMoney,
  IF(a.PayStatus != 0 AND a.ClientPayType = 4, a.ClientMoney, 0) AS ClientCashPayMoney,
  IF(a.PayStatus != 0 AND a.ClientPayType = 5, a.ClientMoney, 0) AS ClientOtherPayMoney,

  -- 11. 其他订单与派送信息
  a.OrderLabel,          -- 订单标签
  a.ConfirmTime,         -- 下单时间
  a.PayTime,             -- 支付时间
  a.CancelTime,          -- 取消时间
  a.DeliveryMethod * 1  AS DeliveryMethod,     -- 配送方式：1=自取，2=派送
  a.IsConfirmDeliveryMethod,                  -- 是否确认配送方式
  a.TaskTime,            -- 派送/自取时间
  a.TaskTimeDay,         -- 派送日期（仅天）
  a.TaskDeliveryAddress, -- 派送地址

  -- 12. 员工与完结信息
  b.CashierName,         -- 开单员工姓名
  b.CashierMobile,       -- 开单员工手机号
  b.EndUserName,         -- 结单员工姓名
  b.EndUserMobile,       -- 结单员工手机号
  b.OrderEndTime,        -- 结单时间

  a.Remark,              -- 客户备注
  IFNULL(d.CardName, '') AS CardName,          -- 会员卡名称（若无则空串）
  SFBackOrderID,         -- 返工订单ID
  a.ExpectBackTime       -- 期望返工时间

FROM t_shop_work_order a
  LEFT JOIN t_shop_work_order_washtask b
    ON a.ID = b.WorkID                -- 派单/开单/结单任务表
  LEFT JOIN t_shop_customer c
    ON a.CustID = c.CustID            -- 客户表
  LEFT JOIN t_shop_card_touser d
    ON a.CustCardID = d.ID            -- 会员卡表

WHERE
  <IDSql 条件>            -- （可选）起始 ID 过滤，用于大表分页优化
  AND a.IsUse = 1;         -- 仅查询“有效”订单
```

## 2.2. 拼接后的完整SQL
```
String Sql =
  // 1. 主查询字段
  "SELECT IFNULL((SELECT e.PayStatus FROM t_shop_work_order_addprice e " +
                 " WHERE e.ParentShopID = '" + ShopID + "'" +
                 "   AND e.PayStatus = 0" +
                 "   AND e.IsUse = 1" +
                 "   AND e.OrderID = a.ID" +
                 "),1) AS AddPriceStatus," +
         " … /* 上面详解过的所有字段 */ …" +
  // 2. 表连接
  " FROM t_shop_work_order a" +
  " LEFT JOIN t_shop_work_order_washtask b ON a.ID = b.WorkID" +
  " LEFT JOIN t_shop_customer c          ON a.CustID = c.CustID" +
  " LEFT JOIN t_shop_card_touser d       ON a.CustCardID = d.ID" +
  // 3. 初始 WHERE
  " WHERE " + IDSql + " a.IsUse = 1" +
  // 4. 店铺过滤：有子店则用 QueryShopID，否则用父店或子店列表
  ( !ToolHelper.isNullOrEmpty(QueryShopID)
      ? " AND a.UsedShopID = '" + QueryShopID + "'"
      : ( ShopID.equals(ParentShopID)
          ? " AND a.ParentShopID = '" + ParentShopID + "'"
          : " AND a.UsedShopID IN " + ShopIDList
        )
  ) +
  // 5. 手机号过滤
  ( !ToolHelper.isNullOrEmpty(Mobile)
      ? ( Mobile.length()==11
          ? " AND c.Mobile = '" + Mobile + "'"
          : " AND c.Mobile LIKE '%" + Mobile + "%'"
        )
      : ""
  ) +
  // 6. 订单号过滤
  ( !ToolHelper.isNullOrEmpty(OrderNo)
      ? " AND a.OrderNo LIKE '%" + OrderNo + "%'"
      : ""
  ) +
  // 7. 来源备注过滤
  ( !ToolHelper.isNullOrEmpty(SourceTypeRemark)
      ? " AND a.SourceTypeRemark LIKE '%" + SourceTypeRemark + "%'"
      : ""
  ) +
  // 8. 时间区间过滤（ConfirmTime/PayTime/CancelTime/OrderEndTime）
  ( !ToolHelper.isNullOrEmpty(StartTime)
      ? " AND " + timeString + " >= '" + StartTime + "'"
      : ""
  ) +
  ( !ToolHelper.isNullOrEmpty(EndTime)
      ? " AND " + timeString + " <= '" + EndTime + "'"
      : ""
  ) +
  // 9. 派送时间过滤
  ( !ToolHelper.isNullOrEmpty(TaskStartTime) || !ToolHelper.isNullOrEmpty(TaskEndTime)
      ? " AND a.DeliveryMethod = 2 AND a.IsConfirmDeliveryMethod = 1"
        + ( !ToolHelper.isNullOrEmpty(TaskStartTime)
            ? " AND a.TaskTime >= '" + TaskStartTime + "'"
            : ""
          )
        + ( !ToolHelper.isNullOrEmpty(TaskEndTime)
            ? " AND a.TaskTime <= '" + TaskEndTime + "'"
            : ""
          )
      : ""
  ) +
  // 10. 用户名、标签、类型、员工、状态过滤……
  ( !ToolHelper.isNullOrEmpty(UserName)
      ? " AND c.UserName LIKE '%" + UserName + "%'"
      : ""
  ) +
  ( !ToolHelper.isNullOrEmpty(OrderLabel)
      ? " AND a.OrderLabel LIKE '%" + OrderLabel + "%'"
      : ""
  ) +
  ( !ToolHelper.isNullOrEmpty(OrderType)
      ? " AND a.OrderType = '" + OrderType + "'"
      : ""
  ) +
  ( !ToolHelper.isNullOrEmpty(CashierMobile)
      ? ( EmployeeType.equals("1")
          ? " AND b.CashierMobile = " + CashierMobile
          : " AND b.EndUserMobile    = " + CashierMobile
        )
      : ""
  ) +
  ( !ToolHelper.isNullOrEmpty(TaskStatus)
      ? " AND b.TaskStatus = '" + TaskStatus + "'"
      : " AND b.TaskStatus IN (5,10,17,11,20,-4,-2,15)"
  ) +
  // 11. 支付方式过滤
  ( !ToolHelper.isNullOrEmpty(PayType)
      ? /* 按 PayType 构造的多分支拼接，见代码中 switch 逻辑 */
        sqlStringForPayType
      : ""
  ) +
  // 12. 支付状态过滤
  ( !ToolHelper.isNullOrEmpty(PayStatus)
      ? " AND a.PayStatus = '" + (PayStatus.equals("2") ? "0" : PayStatus) + "'"
      : ""
  ) +
  // 13. 排序与分页
  " ORDER BY a.CreateTime DESC" +
  " LIMIT " + ((PageNum - 1) * PageSize) + "," + PageSize;
```

## 2.3. 小结

- **核心目的**：一条 SQL 同时拉出订单主表、任务表、客户表、会员卡表的信息，并在 SELECT 中大量使用 `CASE`、`IF`、`IFNULL` 实现各种状态映射、金额拆分和空值填充。

- **思路**：
    1. **预处理**：先定位是否存在未付加价（子查询）；
    2. **基础字段**：直接取主表与关联表字段；
    3. **计算字段**：用 `CASE`/`IF` 按规则算出最终支付渠道和各渠道实付；
    4. **关联查询**：通过 LEFT JOIN 拿到任务、客户和卡信息；
    5. **动态过滤**：将 WHERE 条件留给上层代码拼接，实现高度可配置的多维查询。