# 1. 范围

需要修改两个方法：SubmitAndSubscribe 和 MakeAppointment
SubmitAndSubscribe是下单时接口，若下单时预约了上门时间则先生成订单然后系统自动下单快递上门时间，如果用户预约的上门时间不在套餐的使用期限内则下单失败，直接下单生成服务订单，用户想预约时间时通过MakeAppointment进行预约。

# 2. SubmitAndSubscribe 修改思路

## 2.1. 入口判断

- **区分两种下单模式**
    - **预约下单** (`IsSubscribeFlag=="1"`)：用户在下单时就指定了上门取件时间，需要做使用期校验并且后续要生成预约单。
    - **直接下单** (`IsSubscribeFlag=="0"`)：用户不指定上门时间，只生成服务订单，后面再补约调同样的预约逻辑。

## 2.2. 预约时间校验（仅针对 “预约下单”）

1. **解析用户输入的预约开始日期**
    - 调用 `ToolHelper.GetTaskServiceTime(AppointmentTime)`，把形如 `"6月28日08:00至09:00"` 的字符串，解析成 `"yyyy-MM-dd"` 格式的日期。
      
2. **读取商品的使用有效期**
    - 拿到购买的那个服务 ID（`GoodsIDList` 解 JSON 后的第一个 `ID`）。
    - 从 **t_shop_service_config** 表中查询 `GoodsStartTime`/`GoodsEndTime`。
    - 如果任一字段为空，则视为“永久有效”，跳过校验；否则截取成 `"yyyy-MM-dd"` 两个日期。
    
3. **比对范围**
    - 如果 `TaskServiceTime < GoodsStartTime` 或 `TaskServiceTime > GoodsEndTime`，则直接：
        `返回 { flag=0, msg="商品不在使用期内，不可预约", msgCode="300" }`
    - 校验通过后，才继续后面流程。

## 2.3. 服务订单创建

- **统一入口**，不管哪种模式，先调用：
    `cs = ServicesSubmit(...);`
    在品牌库的 **t_shop_work_service** 表中插入一条服务订单记录

## 2.4. 预约单与派单逻辑

仅当 `IsSubscribeFlag=="1"` 且校验通过后，才进：
1. **生成预约单**
    - 调用 `CreateVirtualReservation(...)`，往主库插入 `IsUse=0` 的预约记录。
2. **自动派单（可选）**
    - 查询服务订单的支付状态与 `IsNeedSubscribe` 字段：
        - 如果用户已付且仍需预约，就调用 `UpdateTaskStatusAndAutoExpress(...)` 下发快递任务。
    - 否则，暂不派单，等待用户后续确认时间。

对于 **“直接下单”**，因为 `IsSubscribeFlag=="0"`，跳过上面所有预约相关逻辑，直接把订单写入后返回，后面再通过补约接口来走一次相同的预约流程。

## 2.5. 异常与回滚

- **校验阶段失败**：直接返回错误，不调用 `ServicesSubmit`（前置校验方案）
- **订单阶段失败**：捕获异常或根据返回 `flag` 判断，返回对应错误码，记录日志
- **预约或派单失败**：捕获并返回 “预约失败” 或者标记订单为无需预约，按需求选择

这样就能保证：

- **预约模式**：先校验使用期，合格后下单并生成预约单／派单；
- **直购模式**：永不做预约时间校验，先下单，后续补约再走相同逻辑。

整个流程清晰地把“校验”、“下单”、“预约”三部分职责分离，又能复用已有的 `ServicesSubmit` 和 `CreateVirtualReservation` 方法。