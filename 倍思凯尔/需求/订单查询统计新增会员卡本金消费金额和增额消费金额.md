# 1. 功能改动需求分析

## 1.1. 背景与目标

### 1.1.1. 背景
会员卡消费总金额包含本金消费金额和赠额消费金额，本金消费金额为客户实际支出的金额，商家想分别知道会员卡消费的本金金额和赠额为多少。
### 1.1.2. 目标
商户后台中订单查询统计中新增显示会员卡本金消费金额和赠额消费金额。

## 1.2. 当前行为 vs 期望行为

|      | 当前                  | 期望                          |
| ---- | ------------------- | --------------------------- |
| 页面展示 | 无会员卡本金消费金额和赠额消费金额字段 | 订单查询统计区新增会员卡本金消费金额和赠额消费金额字段 |
## 1.3. 范围和影响点

### 1.3.1. In-Scrop
订单查询统计区新增会员卡本金消费金额和赠额消费金额字段
### 1.3.2. Out-of-Scrop
无
### 1.3.3. 影响
1. 改动 com.kb.rest.Manager.WechatAppManager.GetSumOrderList()
2. 前端新增显示字段

## 1.4. 任务分解

# 2. GetSumOrderList方法详解
## 2.1. 方法概述

`GetSumOrderList` 是一个静态的 REST 查询方法，用于根据各种条件（如店铺、手机号、订单编号、时间区间、支付方式等）查询洗衣订单的列表及汇总信息，并支持分页返回。最终将结果封装到 `ClsRestCommonReturn` 对象中。

## 2.2. 参数说明

|参数名|含义|
|---|---|
|`Token, TokenType`|授权令牌及类型，用于校验请求合法性|
|`QueryShopID`|指定要查询的子店铺 ID（可选）|
|`Mobile, UserName`|客户手机号、用户名，用于匹配筛选|
|`OrderNo`|订单编号模糊查询|
|`StartTime, EndTime, TimeType`|时间区间及类型（开单/支付/取消/结单），用于设定过滤字段|
|`OrderLabel, TaskStatus, OrderType, SourceTypeRemark`|订单标签、任务状态、订单类型、来源备注|
|`CashierMobile, EmployeeType`|操作员工手机号及员工类型（开单/结单）|
|`PayType, PayStatus, Payment`|支付方式、支付状态，及混合支付时的子方式|
|`TaskStartTime, TaskEndTime`|派送任务的时间区间|
|`PageSize, PageNum`|分页大小和页码|

---

## 2.3. Token 校验

1. 调用 `ToolHelperRest.CheckToKen(Token, TokenType)` 验证令牌合法性；
2. 若返回空或 `Flag==0`，直接设置 `cs.flag=0` 并返回错误信息。

## 2.4. Hibernate 会话管理

1. 根据 `ShopID` 打开主库（`bsession`）和公共库（`session`）；
2. 若会话创建失败，同样返回错误。

## 2.5. 时间字段与起始 ID 预处理

1. 根据 `TimeType`（1–开单，2–支付，3–取消，4–结单）设置对应的数据库字段（`timeString` 等）；
2. 若提供了 `StartTime`，调用 `GetMinIDByShopIDTime` 获得最早一条记录的 ID，以构造 `ID >= StartID` 的过滤，加速大表扫描。

## 2.6. 动态拼装 SQL

- **主查询 SQL (`Sql`)**
    
    - 从 `t_shop_work_order` 及相关联的任务表、客户表、卡片表联合查询所需字段；
    - 用大量 `CASE`/`IFNULL` 表达式计算订单金额、各支付渠道金额、优惠金额等。
    
- **汇总统计 SQL (`Sql_Count`)**
    
    - 统计总订单数、总件数、各支付方式累计金额，用于返回页眉汇总。

## 2.7. 各类过滤条件

按顺序对 SQL 和统计 SQL 追加 `WHERE` 子句，主要包括：

1. **店铺维度**
    - 指定 `UsedShopID` 或父店、子店列表。
    
2. **客户信息**
    - 手机号（精确或模糊）、用户名。
    
3. **订单信息**
    - 订单编号、订单标签、订单类型、来源备注。
    
4. **时间区间**
    - 根据前面确定的 `timeString` 字段，对 `StartTime` / `EndTime` 过滤。
    
5. **任务派送时间**
    - 如果指定 `TaskStartTime/TaskEndTime`，还要确保配送方式为“派送”且已确认。
    
6. **员工筛选**
    - 开单或结单员工手机号。
    
7. **任务状态**
    - 指定 `TaskStatus` 或默认的一组状态。
    
8. **支付方式 & 子方式**
    - 通过 `PayType` 映射不同渠道的金额字段，必要时再细分 `Payment` 子类型。
    
9. **支付状态**
    - 已支付／未支付／已退款（前端 “2” 映射为 “0”）。

## 2.8. 分页与查询执行

1. **统计总数**
    - 执行 `Sql_Count`，获取总记录数 `Num`、总件数 `TotalCloth`、各金额汇总。
    - 计算总页数 `TotalPage = ceil(Num / PageSize)`。
    
2. **分页数据**
    - 在主查询 SQL 尾部追加 `ORDER BY a.CreateTime DESC LIMIT offset, PageSize`。
    - 执行查询并将结果列表放入 `map_result.Rows`。
    
3. **封装返回**
    - 将分页信息、汇总数据、结果列表一起放入 `map_result`，并设置 `cs.flag=1, cs.msg="success", cs.msgCode="200"`。

## 2.9. 异常处理与资源释放
- 在 `catch` 中记录日志并返回超时或服务器错误提示；
- 最终通过 `finally` 块关闭打开的 Hibernate 会话，避免连接泄漏。

**总结**：
- 该方法核心在于“动态拼 SQL + 两次 DB 查询（先统计，再分页） + 丰富的过滤条件 + 数据封装”。
- 适用于业务侧对洗衣订单做多维度筛选、分页展示及汇总报表的场景。