# 1. 事务隔离级别
## 1.1. 为什么需要事务隔离级别

- **背景**：MySQL 是典型的客户端/服务器架构，多个会话可能并发发起事务操作。
- **问题**：事务的隔离性要求串行访问同一数据会严重影响并发性能。
- **解决**：通过设置不同的事务隔离级别，在隔离性和性能之间做权衡。
## 1.2. 事务并发执行可能导致的问题

|问题类型|描述|示例|是否严重|
|---|---|---|---|
|**脏写**（Dirty Write）|一个事务写入了另一个**未提交事务**修改过的数据。|B先改为“关羽”，A又改为“张飞”，B回滚 → A的修改也丢失。|最严重（所有级别都禁止）|
|**脏读**（Dirty Read）|读取到了另一个**未提交事务**写入的数据。|A读取B刚修改的“关羽”，但B后又回滚 → A读到无效值。|比较严重|
|**不可重复读**（Non-Repeatable Read）|读取了另一个事务**已提交的更新结果**，导致多次读取结果不同。|A读两次 name，不一致，因为 B 在中间修改并提交了。|中等严重|
|**幻读**（Phantom Read）|同一条件下的两次查询，结果集记录数不同。|A第一次查 number > 0 得1条，B插入后，A再次查变2条。|较轻但重要|

> 幻读强调**多出来的新记录**，而不是记录减少。记录减少属于**不可重复读**的扩展。
## 1.3. SQL标准定义的四种隔离级别

|隔离级别|脏读|不可重复读|幻读|
|---|---|---|---|
|**READ UNCOMMITTED**|✔|✔|✔|
|**READ COMMITTED**|✘|✔|✔|
|**REPEATABLE READ**|✘|✘|✔|
|**SERIALIZABLE**|✘|✘|✘|
- 所有隔离级别都默认禁止 **脏写（Dirty Write）**。
- 严格程度排序：`READ UNCOMMITTED < READ COMMITTED < REPEATABLE READ < SERIALIZABLE`
## 1.4. MySQL 对事务隔离级别的支持

- **支持全部四种隔离级别**，但行为与 SQL 标准稍有不同：
    - 在 **REPEATABLE READ** 下，MySQL 通过 **间隙锁（Gap Lock）** 可避免幻读。
- **默认隔离级别**：`REPEATABLE READ`
# 2. MVCC原理

## 2.1. MVCC 概述

**MVCC（Multi-Version Concurrency Control，多版本并发控制）** 是 InnoDB 实现读写并发的一种机制，主要作用是在读取数据时避免加锁，从而提升系统并发性能。

> **适用范围**：只对 **READ COMMITTED** 和 **REPEATABLE READ** 两种隔离级别下的普通 `SELECT` 查询生效。
## 2.2. MVCC的两个核心机制

### 1. 版本链（Version Chain）

- **关键隐藏列**（聚簇索引记录中）：
    - `trx_id`：每次被修改时写入当前修改该记录的**事务ID**。
    - `roll_pointer`：指向该记录的 **undo 日志**，用于找回旧版本。
- **更新流程**：  
    每次 `UPDATE` 会生成一条 **undo 日志**，undo 记录中也带 `trx_id` 和 `roll_pointer`，多个版本通过 roll_pointer 串成**版本链**，新版本在链头，旧版本在链尾。
- **注意事项**：
    - `INSERT undo` 仅在回滚时有用，事务提交后其空间会被回收，但 `roll_pointer` 仍保留。
    - `UPDATE undo` 支持回溯历史版本，构成完整版本链。
### 2. ReadView
在读数据时用来判断版本是否对当前事务可见。
**ReadView 主要包含：**

|字段名|含义|
|---|---|
|`m_ids`|当前系统中**活跃的读写事务ID列表**|
|`min_trx_id`|m_ids 中最小的事务 ID|
|`max_trx_id`|当前系统中尚未分配的最小事务 ID（下一个）|
|`creator_trx_id`|当前事务的 ID（只读事务默认为0）|

**可见性判断规则**：
假设读取版本的 `trx_id = t_id`：
1. `t_id == creator_trx_id` → 当前事务自己产生的版本 → 可见
2. `t_id < min_trx_id` → 该版本在 ReadView 生成前已提交 → 可见
3. `t_id ≥ max_trx_id` → 该版本在 ReadView 生成后产生 → 不可见
4. `min_trx_id ≤ t_id < max_trx_id`
    - 若 `t_id ∈ m_ids` → 正在运行中 → 不可见
    - 若 `t_id ∉ m_ids` → 已提交 → 可见

> 如果当前版本不可见，就顺着版本链往下找旧版本，直到找到可见版本或整条链都不可见。

## 2.3. 两种隔离级别下 ReadView 的生成时机

### 1. **READ COMMITTED**：每次查询生成一个新的 ReadView
- 每次 `SELECT` 查询前创建新的 ReadView，因此每次查询结果都可能不同（只要有其他事务提交了新的数据）。
- 可以读取**当前最新已提交**的数据，具备较好的**实时性**。
### 2. **REPEATABLE READ**：整个事务生命周期只生成一次 ReadView
- 只有**第一次查询时**生成 ReadView，之后所有查询都使用这个快照。
- 即使其他事务提交了新版本，当前事务始终读到的是**事务开始时的一致快照**，从而实现**可重复读**。