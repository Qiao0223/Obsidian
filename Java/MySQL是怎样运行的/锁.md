# 1. 解决并发事务带来问题的两种基本方式
## 1.1. 事务并发带来的三种典型操作场景

|类型|特征描述|是否冲突|如何解决|
|---|---|---|---|
|读-读|并发读取相同记录，不改动数据|无冲突|允许并发进行|
|写-写|并发修改相同记录|冲突，导致脏写|加锁（X锁，互斥）|
|读-写/写-读|一方读取，一方修改或插入新记录|冲突，可能造成脏读、不可重复读、幻读|需 MVCC 或加锁解决|

> **注意**：幻读是范围查询导致的插入新记录被“读到”，并非对同一记录冲突。
## 1.2. SQL标准对并发问题的支持

| 隔离级别             | 脏读  | 不可重复读 | 幻读             |
| ---------------- | --- | ----- | -------------- |
| READ UNCOMMITTED | ✔   | ✔     | ✔              |
| READ COMMITTED   | ✘   | ✔     | ✔              |
| REPEATABLE READ  | ✘   | ✘     | ✔（MySQL 实际已解决） |
| SERIALIZABLE     | ✘   | ✘     | ✘              |
## 1.3. 解决并发问题的两种方式

### 方案一：**读用 MVCC，写用加锁（推荐）**

- **读取**通过 MVCC 保证一致性（快照读，不加锁）；
- **写入**仍使用锁，保证数据完整性；
- **好处**：读写并发性能高，适用大多数业务场景。

> 普通 SELECT 在 RC 和 RR 下使用 MVCC，读历史版本不阻塞写操作。

### 方案二：**读写都加锁（全加锁）**

- 在读取时也使用锁（共享锁 S 或排他锁 X）；
- 保证读取的是最新值，**阻塞其他读写操作**；
- 用于 **对数据一致性要求极高** 的场景（如银行账户操作）；
- 会显著影响并发性能。

> 比如幻读场景无法预知要加哪条记录的锁，因此使用范围锁、间隙锁等复杂策略。

## 1.4. 两种读取方式

### 1. **一致性读（Consistent Read）**

|特点|读取记录的历史版本，**不加锁**，使用 MVCC|
|---|---|
|应用|所有普通 `SELECT` 查询在 RC 和 RR 隔离级别下|
|示例|`SELECT * FROM t;`，`SELECT * FROM t1 JOIN t2;`|
|优点|高并发，不阻塞写操作|
### 2. **锁定读（Locking Read）**

- 读取时加锁（S锁或X锁），用于阻止其他事务并发操作；
- MySQL 提供两种特殊语法：

|语法|锁类型|用途|
|---|---|---|
|`SELECT ... LOCK IN SHARE MODE`|共享锁（S锁）|阻止其他事务加 X锁或修改记录|
|`SELECT ... FOR UPDATE`|排他锁（X锁）|阻止其他事务加任意锁（S/X），保证独占访问|
## 1.5. 写操作及加锁机制

### 1. DELETE 操作

- 获取 X锁 → delete mark（标记删除） → 事务提交后才真正清除或放入垃圾链表。
### 2. UPDATE 操作的三种场景

|情况|处理方式|
|---|---|
|修改非主键字段，且存储空间不变|原地修改 + 获取 X锁|
|修改非主键字段，但存储空间发生变化|删除旧记录 + 插入新记录（X锁 + 隐式锁）|
|修改主键字段|DELETE + INSERT 操作（两次加锁）|
### 3. INSERT 操作

- 一般不显式加锁，**由“隐式锁”机制保护新记录**；
- 特殊场景（如唯一键冲突）下也可能显式加锁。

# 2. 多粒度锁
## 2.1. 锁的粒度
|锁类型|粒度|作用范围|描述|
|---|---|---|---|
|行锁（Record Lock）|细|某一条记录|精准控制并发，锁冲突少，性能好|
|表锁（Table Lock）|粗|整张表|操作简单，但并发度低|
|意向锁（Intention Lock）|辅助|表级别|标记“某些记录被加了行锁”，帮助表锁判断是否能加|
## 2.2. 表级 S 锁 与 X 锁 的行为
| 操作事务   | 其他事务行为                     | 说明           |
| ------ | -------------------------- | ------------ |
| 表级 S 锁 | 继续加表S锁、行S锁  <br>无法加表X锁、行X锁 | 可多个事务共享表进行只读 |
| 表级 X 锁 | 无法加任何锁（S、X，表/行级）           | 完全独占，读写全阻塞   |
## 2.3. 意向锁（Intention Locks）
|类型|英文名|加锁时机|作用|
|---|---|---|---|
|**IS锁**|_Intention Shared Lock_|准备给记录加 S 锁前，先给表加 IS 锁|标记“某些行要加 S 锁”|
|**IX锁**|_Intention Exclusive Lock_|准备给记录加 X 锁前，先给表加 IX 锁|标记“某些行要加 X 锁”|

> **作用核心**：辅助判断表级 S 锁、X 锁是否可以安全加锁，**避免遍历记录**。

# 3. MySQL中的表锁

## 3.1. InnoDB不会默认使用表级S锁/X锁：

- 常规 `SELECT` / `INSERT` / `UPDATE` / `DELETE` 并不会对表添加表级锁。
- 但执行 `ALTER TABLE` / `DROP TABLE` 等 **DDL 语句** 时会加锁，造成并发阻塞。
- 实现机制是 **元数据锁(MDL)**，而非InnoDB自身的表锁。

## 3.2. 手动表锁（不推荐）：

- `LOCK TABLES t READ`：手动加 **表级S锁**
- `LOCK TABLES t WRITE`：手动加 **表级X锁**

> 不推荐使用，降低并发性能。

## 3.3. IS锁 / IX锁（内部机制）：

- 加行级S锁前 ➜ 需先加表级 **IS锁**；
- 加行级X锁前 ➜ 需先加表级 **IX锁**；
- 用于辅助判断是否有记录已加锁，避免全表扫描。

## 3.4. AUTO-INC锁（插入自增值时用）：

- 插入含 `AUTO_INCREMENT` 字段记录时用到：
    - **AUTO-INC锁**（表锁）：适用于插入记录数不确定（如 `INSERT...SELECT`）
    - **轻量锁**（非表锁）：插入记录数确定时使用，提升性能。

# 4. MySQL中的行锁

1. **Record Locks（正经记录锁）**：
    - 官方名：`LOCK_REC_NOT_GAP`
    - 加锁对象：具体某条记录
    - S型/X型分别对应共享/排他锁
2. **Gap Locks（间隙锁）**：
    - 官方名：`LOCK_GAP`
    - 加锁对象：索引记录之间的间隙（防幻读）
    - 不影响已有记录，但禁止间隙插入新记录
3. **Next-Key Locks（记录+间隙锁）**：
    - 官方名：`LOCK_ORDINARY`
    - = Record Lock + Gap Lock
    - 既锁住记录本身，也锁住前方间隙
4. **Insert Intention Locks（插入意向锁）**：
    - 官方名：`LOCK_INSERT_INTENTION`
    - 表示某事务有意图在某个间隙插入记录
    - 遇到 gap lock 会等待；彼此间不会互相阻塞
5. **隐式锁（Implicit Lock）**：
    - 插入记录时未显式加锁，但记录携带事务id
    - 其他事务读取/加锁时自动生成锁结构
    - 基于 `trx_id` 判断记录归属，防止脏读/脏写