# 1. 解决并发事务带来问题的两种基本方式
## 1.1. 事务并发带来的三种典型操作场景

|类型|特征描述|是否冲突|如何解决|
|---|---|---|---|
|读-读|并发读取相同记录，不改动数据|无冲突|允许并发进行|
|写-写|并发修改相同记录|冲突，导致脏写|加锁（X锁，互斥）|
|读-写/写-读|一方读取，一方修改或插入新记录|冲突，可能造成脏读、不可重复读、幻读|需 MVCC 或加锁解决|

> **注意**：幻读是范围查询导致的插入新记录被“读到”，并非对同一记录冲突。
## 1.2. SQL标准对并发问题的支持

| 隔离级别             | 脏读  | 不可重复读 | 幻读             |
| ---------------- | --- | ----- | -------------- |
| READ UNCOMMITTED | ✔   | ✔     | ✔              |
| READ COMMITTED   | ✘   | ✔     | ✔              |
| REPEATABLE READ  | ✘   | ✘     | ✔（MySQL 实际已解决） |
| SERIALIZABLE     | ✘   | ✘     | ✘              |
## 1.3. 解决并发问题的两种方式

### 方案一：**读用 MVCC，写用加锁（推荐）**

- **读取**通过 MVCC 保证一致性（快照读，不加锁）；
- **写入**仍使用锁，保证数据完整性；
- **好处**：读写并发性能高，适用大多数业务场景。

> 普通 SELECT 在 RC 和 RR 下使用 MVCC，读历史版本不阻塞写操作。

### 方案二：**读写都加锁（全加锁）**

- 在读取时也使用锁（共享锁 S 或排他锁 X）；
- 保证读取的是最新值，**阻塞其他读写操作**；
- 用于 **对数据一致性要求极高** 的场景（如银行账户操作）；
- 会显著影响并发性能。

> 比如幻读场景无法预知要加哪条记录的锁，因此使用范围锁、间隙锁等复杂策略。

## 1.4. 两种读取方式

### 1. **一致性读（Consistent Read）**

|特点|读取记录的历史版本，**不加锁**，使用 MVCC|
|---|---|
|应用|所有普通 `SELECT` 查询在 RC 和 RR 隔离级别下|
|示例|`SELECT * FROM t;`，`SELECT * FROM t1 JOIN t2;`|
|优点|高并发，不阻塞写操作|
### 2. **锁定读（Locking Read）**

- 读取时加锁（S锁或X锁），用于阻止其他事务并发操作；
- MySQL 提供两种特殊语法：

|语法|锁类型|用途|
|---|---|---|
|`SELECT ... LOCK IN SHARE MODE`|共享锁（S锁）|阻止其他事务加 X锁或修改记录|
|`SELECT ... FOR UPDATE`|排他锁（X锁）|阻止其他事务加任意锁（S/X），保证独占访问|
## 1.5. 写操作及加锁机制

### 1. DELETE 操作

- 获取 X锁 → delete mark（标记删除） → 事务提交后才真正清除或放入垃圾链表。
### 2. UPDATE 操作的三种场景

|情况|处理方式|
|---|---|
|修改非主键字段，且存储空间不变|原地修改 + 获取 X锁|
|修改非主键字段，但存储空间发生变化|删除旧记录 + 插入新记录（X锁 + 隐式锁）|
|修改主键字段|DELETE + INSERT 操作（两次加锁）|
### 3. INSERT 操作

- 一般不显式加锁，**由“隐式锁”机制保护新记录**；
- 特殊场景（如唯一键冲突）下也可能显式加锁。

# 2. 多粒度锁
## 2.1. 锁的粒度
|锁类型|粒度|作用范围|描述|
|---|---|---|---|
|行锁（Record Lock）|细|某一条记录|精准控制并发，锁冲突少，性能好|
|表锁（Table Lock）|粗|整张表|操作简单，但并发度低|
|意向锁（Intention Lock）|辅助|表级别|标记“某些记录被加了行锁”，帮助表锁判断是否能加|
## 2.2. 表级 S 锁 与 X 锁 的行为
| 操作事务   | 其他事务行为                     | 说明           |
| ------ | -------------------------- | ------------ |
| 表级 S 锁 | 继续加表S锁、行S锁  <br>无法加表X锁、行X锁 | 可多个事务共享表进行只读 |
| 表级 X 锁 | 无法加任何锁（S、X，表/行级）           | 完全独占，读写全阻塞   |
## 2.3. 意向锁（Intention Locks）
|类型|英文名|加锁时机|作用|
|---|---|---|---|
|**IS锁**|_Intention Shared Lock_|准备给记录加 S 锁前，先给表加 IS 锁|标记“某些行要加 S 锁”|
|**IX锁**|_Intention Exclusive Lock_|准备给记录加 X 锁前，先给表加 IX 锁|标记“某些行要加 X 锁”|

> **作用核心**：辅助判断表级 S 锁、X 锁是否可以安全加锁，**避免遍历记录**。