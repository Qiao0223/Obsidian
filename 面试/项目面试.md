---
number headings: first-level 1, start-at 1, max 4, 1.1, auto, contents ^toc
---
# 1 黑马点评商户查询与缓存是如何实现的？

当用户发起带有 merchantId 的商户查询请求时，系统首先将 merchantId 传给布隆过滤器进行校验；如果布隆过滤器判断该商户不存在，则直接返回“商户不存在”；否则，系统会先尝试从 Redis 缓存（键名为 "shop:" + merchantId）中读取商户数据，如果命中就直接返回缓存结果；若缓存未命中，则尝试获取分布式锁（键名为 "lock:shop:merchantId"），若获取成功，需在持有锁时再次检查缓存（以防在等待锁期间其他线程已完成缓存填充），若此时缓存已命中则释放锁并返回数据；如果缓存仍未命中，则去数据库的 shop 表中查询该 merchantId 对应的记录，如果数据库也未查到，则向 Redis 写入一个带有短期 TTL（例如 60 秒）的空对象防止缓存穿透，释放锁并返回“商户不存在”；若数据库查询到实体，则将该实体写入 Redis 缓存并设置基础 TTL 加随机抖动以防缓存雪崩，释放锁后返回商户数据；如果尝试获取分布式锁时失败，则短暂等待（如 50 ms）后循环检查缓存命中情况，若在超时时间内读取到缓存则返回数据，否则在等待超时后返回“稍后重试”。
![[黑马点评商户查询.svg]]

# 2 黑马点评怎么实现的秒杀？

当用户访问 `/vouchers/seckill/claim/{voucherId}` 发起秒杀请求时，服务首先获取当前时间并与秒杀活动的开始和结束时间对比，如果未在活动时间范围内则立即返回“秒杀未开始或已结束”；如果在活动期间，接着读取 Redis 中对应 `seckill:stock:{voucherId}` 的库存值（stock），若库存不大于 0 则返回“库存不足”；然后检查 Redis Set `seckill:users:{voucherId}` 中是否已存在该用户 ID，若已存在则返回“您已参与过秒杀”；否则使用 Redis 原子操作 `DECR stockKey` 将库存减一，如果减完后库存小于 0，则在 Set 中移除该用户并返回“库存已售罄”；如果库存减扣成功，就将用户 ID 添加到 Set 中、调用 RedisIdWorker 生成全局唯一的订单 ID，再将 `{orderId, userId, voucherId, shopId}` 封装成秒杀消息发送到 Kafka 的 `seckill_exchange`，最后将订单 ID 返回给前端。消费者从队列拉取消息，取出 `orderId`、`userId`、`voucherId`、`shopId`，先在数据库表 `tb_voucher_order` 中判断该用户是否已对该券下过单（去重幂等处理），如果已存在则丢弃；若不存在，则对 `tb_seckill_voucher` 表使用乐观锁执行 `UPDATE … SET stock = stock - 1 WHERE voucher_id = … AND stock > 0`，如果受影响行数为 0 表示库存已耗尽，则丢弃消息；否则在 `tb_voucher_order` 表插入新订单记录，完成秒杀下单流程。
![[黑马点评秒杀优惠券.svg]]