---
number headings: first-level 1, start-at 1, max 4, 1.1, auto, contents ^toc
---
# 1 黑马点评商户查询与缓存是如何实现的？

当用户发起带有 merchantId 的商户查询请求时，系统首先将 merchantId 传给布隆过滤器进行校验；如果布隆过滤器判断该商户不存在，则直接返回“商户不存在”；否则，系统会先尝试从 Redis 缓存（键名为 "shop:" + merchantId）中读取商户数据，如果命中就直接返回缓存结果；若缓存未命中，则尝试获取分布式锁（键名为 "lock:shop:merchantId"），若获取成功，需在持有锁时再次检查缓存（以防在等待锁期间其他线程已完成缓存填充），若此时缓存已命中则释放锁并返回数据；如果缓存仍未命中，则去数据库的 shop 表中查询该 merchantId 对应的记录，如果数据库也未查到，则向 Redis 写入一个带有短期 TTL（例如 60 秒）的空对象防止缓存穿透，释放锁并返回“商户不存在”；若数据库查询到实体，则将该实体写入 Redis 缓存并设置基础 TTL 加随机抖动以防缓存雪崩，释放锁后返回商户数据；如果尝试获取分布式锁时失败，则短暂等待（如 50 ms）后循环检查缓存命中情况，若在超时时间内读取到缓存则返回数据，否则在等待超时后返回“稍后重试”。
![[黑马点评商户查询.svg]]

# 2 黑马点评怎么实现的秒杀？

当用户访问 `/vouchers/seckill/claim/{voucherId}` 发起秒杀请求时，服务首先获取当前时间并与秒杀活动的开始和结束时间对比，如果未在活动时间范围内则立即返回“秒杀未开始或已结束”；如果在活动期间，接着读取 Redis 中对应 `seckill:stock:{voucherId}` 的库存值（stock），若库存不大于 0 则返回“库存不足”；然后检查 Redis Set `seckill:users:{voucherId}` 中是否已存在该用户 ID，若已存在则返回“您已参与过秒杀”；否则使用 Redis 原子操作 `DECR stockKey` 将库存减一，如果减完后库存小于 0，则在 Set 中移除该用户并返回“库存已售罄”；如果库存减扣成功，就将用户 ID 添加到 Set 中、调用 RedisIdWorker 生成全局唯一的订单 ID，再将 `{orderId, userId, voucherId, shopId}` 封装成秒杀消息发送到 Kafka 的 `seckill_exchange`，最后将订单 ID 返回给前端。消费者从队列拉取消息，取出 `orderId`、`userId`、`voucherId`、`shopId`，先在数据库表 `tb_voucher_order` 中判断该用户是否已对该券下过单（去重幂等处理），如果已存在则丢弃；若不存在，则对 `tb_seckill_voucher` 表使用乐观锁执行 `UPDATE … SET stock = stock - 1 WHERE voucher_id = … AND stock > 0`，如果受影响行数为 0 表示库存已耗尽，则丢弃消息；否则在 `tb_voucher_order` 表插入新订单记录，完成秒杀下单流程。
![[黑马点评秒杀优惠券.svg]]

# 3 黑马店面登录验证流程是怎么样的？

## 3.1 简洁版

用户在前端输入手机号并发起“发送验证码”请求时，后端先通过 Redis 限制同一手机号一分钟内重复发送和单日发送次数，生成 6 位验证码存入 Redis 并调用短信网关发送；用户收到验证码后提交手机号和验证码登录，后端从 Redis 校验验证码是否存在且匹配，匹配成功后删除验证码，并在数据库查询或创建对应用户，生成全局唯一的 token，将 token 和用户信息以 JSON 形式存入 Redis 并返回给前端；此后所有需鉴权的请求都会由拦截器从请求头提取 token，到 Redis 中验证并反序列化为用户信息注入到线程上下文，若 token 过期或不存在则提示重新登录，否则续期会话并放行请求。

## 3.2 详细版

当用户在前端输入手机号并点击“发送验证码”时，后端首先在 Redis 中检查键 `LOGIN_CODE_REPEAT_{phone}` 是否存在，以防同一手机号一分钟内重复发送；如果该键存在，则直接返回“请稍后再试”；否则，再通过 `INCR LOGIN_CODE_COUNT_{phone}` 统计该手机号当天短信请求次数，并判断是否超过预设上限（例如 10 次），如果超过则返回“今日已达最大发送次数”，否则继续处理。接着，系统随机生成一个六位数字验证码 `code`，将其以键 `LOGIN_CODE_{phone}` 存入 Redis，设置 5 分钟过期，同时写入一条过期时间为 60 秒的 `LOGIN_CODE_REPEAT_{phone}` 用于一分钟内的重复发送限制，并调用外部短信网关将验证码发送到用户手机；若短信发送或 Redis 写入失败，则返回相应错误提示。用户收到验证码后，在登录页面再次输入手机号与验证码并提交 `/login?phone={phone}&code={code}` 请求，后端首先验证参数是否为空，如果为空则返回“参数错误”；否则从 Redis 读取 `LOGIN_CODE_{phone}` 键对应的 `cachedCode`，若 `cachedCode` 不存在则说明验证码已过期，立即返回“验证码已失效，请重新获取”；若 `cachedCode` 与用户输入不匹配，则返回“验证码错误”；当验证码校验通过后，后端立即删除 Redis 中的 `LOGIN_CODE_{phone}`，以避免重复使用相同验证码。然后系统通过手机号在数据库的 `user` 表中查询用户信息，如果未查询到则创建一个新的用户记录（包括手机号、默认昵称和头像等），并获取刚插入的 `userId`，若已存在则直接获取该用户的 `userId`。接下来，后端基于 `RedisIdWorker.nextId("login")` 生成一个全局唯一的长整型 ID，将其转换为字符串 `token`，再将包含 `userId`、昵称、头像、积分等必要字段的 `UserDTO` 序列化为 JSON，并以键 `LOGIN_USER_{token}` 存入 Redis，设置会话过期时间（例如 30 分钟）。最后，将 `token` 返回给前端，前端可将其放在 HTTP 请求头（如 `Authorization: Bearer {token}`）或本地存储中，用于后续请求。此后，所有需要用户身份验证的接口都被统一拦截器拦截：拦截器先从请求头中提取 `token`，若 `token` 为空则立即返回“未登录，请先登录”；否则以 `LOGIN_USER_{token}` 为键到 Redis 中获取对应的用户 JSON，若 Redis 中不存在该键（表示会话过期或 `token` 无效），则返回“登录已过期，请重新登录”；如果获取成功，就将 JSON 反序列化为 `UserDTO` 并存放到当前线程的 `ThreadLocal` 中，以便在后续业务逻辑中调用 `UserHolder.getUser()` 直接获取用户信息，同时（可选地）将该 Redis 键的过期时间重置回 30 分钟，实现“滑动过期”。当具体业务逻辑执行完成后，拦截器会在响应返回前清理线程的 `ThreadLocal`，防止线程复用时用户信息泄露。这样，整个登录与验证流程既结合了 Redis 的高效读写和过期机制，又利用数据库唯一索引避免并发注册冲突，同时通过拦截器保证了每次后续请求都要经过令牌校验，能够在高并发场景下为用户提供安全、可靠且性能稳定的登录验证服务。
![[黑马点评登录验证.svg]]

# 4 黑马点评点赞流程是怎样的？

当用户点击“点赞/取消”按钮并发送包含 token 的 `POST /blog/like/{blogId}` 请求后，系统拦截器会先验证 token、解析出 userId 并放入线程上下文；服务层拿到 userId 后，拼接对应笔记的 Redis Set 键（`blog:liked:{blogId}`）和全局排行榜 ZSet 键（`blog:liked:ranking`），通过 `SISMEMBER` 判断用户是否已点赞：若未点赞，则先在数据库中将该笔记的 `liked` 字段 +1，再把 userId 添加到 Set 中，最后调 `ZINCRBY blog:liked:ranking 1 {blogId}` 将该笔记在 ZSet 中的分数加 1，以更新排行榜，然后返回“点赞成功”；若已点赞，则在数据库将 `liked` 字段 -1，将 userId 从 Set 中删除，并调 `ZINCRBY blog:liked:ranking -1 {blogId}` 将该笔记在 ZSet 中的分数减 1，以此维护排行榜，最后返回“已取消点赞”。
![[黑马点评探店笔记点赞.svg]]
