# 1. JVM 架构组成

JVM 的整体架构主要包括以下几个核心组件：

## 1.1. 类加载器子系统（Class Loader Subsystem）

负责将 `.class` 文件加载到内存中，并完成验证、准备、解析和初始化等步骤。类加载器采用双亲委派模型，包括：[维基百科](https://zh.wikipedia.org/wiki/Java%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8?utm_source=chatgpt.com)

- **引导类加载器（Bootstrap ClassLoader）**：加载 Java 核心类库。
- **扩展类加载器（Extension ClassLoader）**：加载扩展类库。
- **应用类加载器（Application ClassLoader）**：加载应用程序的类。

这种机制确保了 Java 核心类的安全性和一致性。

## 1.2. 运行时数据区（Runtime Data Areas）

JVM 在执行 Java 程序时会划分出若干内存区域：

- **程序计数器（Program Counter Register）**：每个线程都有一个，用于指示当前线程执行的字节码行号。
- **Java 虚拟机栈（JVM Stack）**：每个线程私有，存储方法调用的局部变量、操作数栈、动态链接和方法出口等信息。
- **本地方法栈（Native Method Stack）**：为本地方法（Native）服务。
- **堆（Heap）**：所有线程共享，用于存放对象实例和数组，是垃圾回收器管理的主要区域。
- **方法区（Method Area）**：所有线程共享，存储已被虚拟机加载的类信息、常量、静态变量等。

在 JDK 8 之后，方法区被移除，取而代之的是元空间（Metaspace），它使用本地内存而非虚拟机内存。

## 1.3. 执行引擎（Execution Engine）

负责执行字节码，包括：

- **解释器（Interpreter）**：逐条解释执行字节码。
- **即时编译器（JIT Compiler）**：将热点代码编译为机器码，提高执行效率。

## 1.4. 本地接口（Native Interface）

提供与本地库（如 C/C++ 编写的库）的交互能力，允许 Java 程序调用本地方法。

# 2. Java 内存模型（Java Memory Model）

## 2.1. 核心概念

### 1. 主内存与工作内存

- **主内存（Main Memory）**：存储所有线程共享的变量，包括实例字段、静态字段和数组元素。
- **工作内存（Working Memory）**：每个线程私有，存储该线程使用的变量副本。线程对变量的所有操作（读取、写入）必须在工作内存中进行，不能直接访问主内存中的变量。

线程之间的变量值传递必须通过主内存完成，即一个线程修改了共享变量的值，必须刷新到主内存中，其他线程才能读取到最新的值。 

### 2. 可见性、原子性和有序性

- **可见性**：一个线程对共享变量的修改，其他线程能够立即得知。JMM 通过定义主内存和工作内存的交互规则，确保可见性。
- **原子性**：一个操作或多个操作要么全部执行完毕且不被中断，要么完全不执行。Java 提供了 `synchronized`、`volatile` 和原子类（如 `AtomicInteger`）来保证原子性。
- **有序性**：程序执行的顺序按照代码的先后顺序执行。JMM 允许编译器和处理器对指令进行重排序，但通过 `happens-before` 原则来保证有序性。

### 3. Happens-Before 原则

`happens-before` 是 JMM 中定义的一个重要原则，用于判断操作之间的执行顺序。如果一个操作 `A` `happens-before` 操作 `B`，那么操作 `A` 的结果对操作 `B` 是可见的，且操作 `A` 的执行顺序先于操作 `B`。

常见的 `happens-before` 关系包括：

- 程序顺序规则：在一个线程内，按照代码顺序，前面的操作 `happens-before` 后面的操作。
- 监视器锁规则：对一个锁的解锁 `happens-before` 于随后对这个锁的加锁。
- volatile 变量规则：对一个 `volatile` 变量的写操作 `happens-before` 于后续对这个变量的读操作。
- 线程启动规则：调用 `Thread.start()` 方法 `happens-before` 于该线程的每一个动作。
- 线程终结规则：线程中的所有操作 `happens-before` 于其他线程检测到该线程已经终止（通过 `Thread.join()` 等方式）。

## 2.2. 内存交互操作

JMM 定义了以下八种操作，用于描述主内存与工作内存之间的交互：

1. **lock**：作用于主内存变量，把一个变量标识为线程独占状态。
2. **unlock**：作用于主内存变量，释放被锁定的变量。
3. **read**：作用于主内存变量，把一个变量的值从主内存传输到线程的工作内存中，以便随后的 load 操作使用。
4. **load**：作用于工作内存变量，把 read 操作从主内存中得到的变量值放入工作内存的变量副本中。
5. **use**：作用于工作内存变量，把工作内存中的变量值传递给执行引擎。
6. **assign**：作用于工作内存变量，把一个从执行引擎接收到的值赋给工作内存的变量。
7. **store**：作用于工作内存变量，把工作内存中的变量值传送到主内存中，以便后续的 write 操作。
8. **write**：作用于主内存变量，把 store 操作从工作内存中得到的变量值放入主内存的变量中。

这些操作必须按顺序执行，以确保数据的一致性和可见性。

# 3. 垃圾回收机制

Java 的垃圾回收（Garbage Collection，GC）机制是 JVM 自动内存管理的核心功能，旨在自动识别并回收不再被使用的对象，从而释放内存资源，避免内存泄漏和程序崩溃。

## 3.1. 对象存活判断机制

JVM 主要通过以下两种方式判断对象是否仍然存活：

1. **引用计数法（Reference Counting）**：为每个对象添加一个引用计数器，每当有一个地方引用它时，计数器加一；引用失效时，计数器减一。当计数器为零时，表示对象可以被回收。该方法简单高效，但无法解决对象之间相互引用的问题，容易导致内存泄漏，因此已被淘汰。

2. **可达性分析算法（Reachability Analysis）**：从一组称为“GC Roots”的对象出发，沿着引用链向下搜索，能到达的对象被认为是存活的，无法到达的对象则被判定为可回收。GC Roots 通常包括：
    
    - 虚拟机栈中引用的对象
    - 方法区中类静态属性引用的对象
    - 方法区中常量引用的对象
    - 本地方法栈中 JNI（Native 方法）引用的对象

可达性分析算法是当前主流的对象存活判断机制。

## 3.2. 常见的垃圾回收算法

JVM 中常用的垃圾回收算法包括：

1. **标记-清除算法（Mark-Sweep）**：
    
    - **过程**：首先标记出所有需要回收的对象，然后统一回收这些对象所占用的内存。
    - **优点**：实现简单。
    - **缺点**：会产生大量不连续的内存碎片，影响程序性能。
    
2. **复制算法（Copying）**：
    
    - **过程**：将内存划分为两个等大小的区域，每次只使用其中一个。当该区域用完时，将存活的对象复制到另一个区域，然后清空当前区域。
    - **优点**：解决了内存碎片问题，适用于对象存活率低的场景。
    - **缺点**：内存利用率低，浪费了一半的空间。[CSDN](https://blog.csdn.net/abc123mma/article/details/128037723?utm_source=chatgpt.com)
        
3. **标记-整理算法（Mark-Compact）**：
    
    - **过程**：首先标记出所有需要回收的对象，然后将存活的对象向一端移动，最后清理掉边界以外的内存。
    - **优点**：解决了内存碎片问题，适用于对象存活率高的场景。
    - **缺点**：移动对象需要更新所有引用，成本较高。
    
4. **分代收集算法（Generational Collection）**：
    
    - **思想**：根据对象的生命周期将内存划分为新生代、老年代和永久代（或元空间），分别采用不同的回收算法。
    - **优点**：提高了回收效率，减少了停顿时间。
    - **缺点**：实现复杂，需要维护多个内存区域。

## 3.3. 常见的垃圾收集器

### 1. Serial GC（串行回收器）

- **算法类型**：新生代使用复制算法，老年代使用标记-整理算法。
- **作用区域**：新生代和老年代。
- **特点**：所有垃圾回收操作在单线程中执行，适用于单核处理器或对响应时间要求不高的应用。
- **优点**：实现简单，内存占用小。
- **缺点**：在垃圾回收期间会暂停所有应用线程（Stop-The-World），不适合多核处理器和对延迟敏感的应用。

### 2. Parallel GC（并行回收器）

- **算法类型**：新生代使用复制算法，老年代使用标记-整理算法。
- **作用区域**：新生代和老年代。
- **特点**：使用多线程并行执行垃圾回收操作，旨在提高吞吐量。
- **优点**：在多核处理器上性能优越，适合对吞吐量要求高的应用。
- **缺点**：垃圾回收期间仍会暂停所有应用线程，可能导致较长的暂停时间。

### 3. CMS GC（并发标记清除回收器）

- **算法类型**：老年代使用标记-清除算法。
- **作用区域**：主要作用于老年代。
- **特点**：通过与应用线程并发执行的方式减少停顿时间。
- **优点**：减少了垃圾回收对应用的影响，适合对响应时间要求高的应用。
- **缺点**：可能导致内存碎片，且在某些阶段仍需暂停应用线程。
- **状态**：已在 Java 9 中被标记为弃用，并在 Java 14 中被移除。

### 4. ParNew GC

- **算法类型**：新生代使用复制算法。
- **作用区域**：新生代。
- **特点**：是 Serial GC 的多线程版本，常与 CMS GC 搭配使用。
- **优点**：在多核处理器上性能更好，适合与 CMS GC 结合使用。
- **缺点**：单独使用时性能提升有限，主要优势在于与 CMS GC 的配合。

### 5. Parallel Scavenge GC（吞吐量优先回收器）

- **算法类型**：新生代使用复制算法。
- **作用区域**：新生代。
- **特点**：强调吞吐量，提供参数以控制最大停顿时间和吞吐量目标。
- **优点**：适合批处理和后台处理等对吞吐量要求高的应用。
- **缺点**：可能导致较长的垃圾回收停顿时间，不适合对响应时间要求高的应用。

## 3.4. G1 GC

### 1. 内存结构与分区机制

G1 将整个堆划分为多个大小相等的区域（Region），每个 Region 的大小通常在 1MB 到 32MB 之间，具体取决于堆的总大小。这些 Region 在逻辑上被划分为不同的角色：

- **Eden 区**：新对象的初始分配区域。
- **Survivor 区**：存活对象在新生代中的过渡区域。
- **Old 区**：长期存活对象的存储区域。
- **Humongous 区**：用于存储大于一个 Region 一半大小的巨型对象，这些对象可能会占用多个连续的 Region。

这种分区机制使得 G1 能够灵活地管理内存，避免了传统分代模型中固定区域大小带来的限制。

### 2. 回收流程

#### 1. 年轻代回收（Young GC）

- **触发条件**：Eden 区填满时触发。
- **回收范围**：Eden 和 Survivor 区域。
- **过程**：
    
    1. **根扫描**：从 GC Roots 开始标记直接可达的对象。
    2. **更新 RSet**：处理 dirty card 队列，更新 Remembered Set。
    3. **处理 RSet**：识别被老年代对象指向的 Eden 中的对象。
    4. **对象复制**：将存活对象复制到 Survivor 区或晋升到 Old 区。
    5. **处理引用**：处理软引用、弱引用、虚引用等。

此过程为 Stop-The-World（STW）事件，暂停所有应用线程，耗时较短。

#### 2. 并发标记阶段（Concurrent Marking）

- **触发条件**：老年代占用达到一定比例（由 `-XX:InitiatingHeapOccupancyPercent` 控制，默认值为 45%）时触发。
- **过程**：
    
    1. **初始标记（Initial Mark）**：标记从 GC Roots 开始直接可达的对象。此阶段为 STW。
    2. **并发标记（Concurrent Mark）**：与应用线程并发执行，从 GC Roots 开始对堆中对象进行可达性分析，递归扫描整个堆里的对象图，找出要回收的对象。
    3. **最终标记（Remark）**：对并发标记过程中发生变化的对象进行标记。此阶段为 STW。
    4. **筛选回收（Cleanup）**：根据标记信息，选择回收价值高的 Region 进行回收。

并发标记阶段的目的是识别出老年代中垃圾比例高的 Region，为后续的混合回收做准备。

#### 3. 混合回收（Mixed GC）

- **触发条件**：并发标记阶段完成后，触发多次 Mixed GC。
- **回收范围**：Eden、Survivor 和部分 Old 区域。
- **过程**：
    
    1. **选择回收集（CSet）**：根据 Region 的回收价值和成本，选择回收价值高的 Region 组成回收集。
    2. **复制存活对象**：将回收集中存活的对象复制到空的 Region 中。
    3. **清理旧 Region**：清理回收集中的旧 Region，释放内存。

Mixed GC 是 G1 GC 的核心特性，通过多次小规模的回收，避免了 Full GC 的长时间停顿。

#### 4. 完全回收（Full GC）

- **触发条件**：内存不足或其他特殊情况。
- **回收范围**：整个堆，包括所有 Region。
- **过程**：
    
    1. **标记**：标记所有可达对象。
    2. **清除**：清除未被标记的对象。
    3. **整理**：整理内存，消除碎片。

Full GC 是 STW 事件，暂停所有应用线程，耗时较长，应尽量避免。

### 3. 核心机制与优化策略

- **Remembered Set（RSet）**：记录其他 Region 中指向该 Region 的引用，避免在回收时扫描整个堆。
- **Snapshot-At-The-Beginning（SATB）**：在并发标记阶段，记录对象在标记开始时的状态，确保垃圾回收的准确性。
- **停顿时间预测模型**：通过参数 `-XX:MaxGCPauseMillis` 设置期望的最大 GC 停顿时间，G1 GC 会根据历史数据和当前堆的使用情况，预测和调整回收的 Region 数量，以尽量满足这一目标。

## 3.5. 垃圾回收的触发时机

垃圾回收的触发通常由以下情况引起：

- 新生代空间不足时，触发 Minor GC。
- 老年代空间不足时，触发 Major GC 或 Full GC。
- 调用 `System.gc()` 方法，建议 JVM 进行 Full GC，但不保证立即执行。
- 元空间（Metaspace）或永久代（PermGen）空间不足时，触发 Full GC。

## 3.6. 垃圾回收调优建议

- **选择合适的垃圾收集器**：根据应用的特点选择合适的垃圾收集器，例如对响应时间要求高的应用可以选择 G1、ZGC 或 Shenandoah。
- **设置合理的堆内存大小**：通过 `-Xms` 和 `-Xmx` 参数设置堆的初始和最大大小，避免频繁的垃圾回收。
- **监控垃圾回收情况**：使用 `jstat`、`jconsole`、`VisualVM` 等工具监控垃圾回收的频率和停顿时间，及时调整参数。
- **优化代码**：避免创建大量短生命周期的对象，减少对象的创建和销毁次数。

# 4. 类加载机制

JVM 的类加载过程包括：

1. **加载（Loading）**：查找并导入类的二进制数据。
2. **验证（Verification）**：确保导入类的正确性。
3. **准备（Preparation）**：为类的静态变量分配内存并初始化默认值。
4. **解析（Resolution）**：将符号引用转换为直接引用。
5. **初始化（Initialization）**：执行类构造器 `<clinit>` 方法，初始化静态变量。

类加载器采用双亲委派模型，确保了 Java 核心类的安全性和一致性。

# 5. 性能调优

- **内存参数配置**：通过 `-Xms` 和 `-Xmx` 设置堆的初始和最大大小。
- **GC 参数调整**：选择合适的垃圾收集器，如 `-XX:+UseG1GC`。
- **监控工具**：使用 `jstat`、`jmap`、`jconsole`、`VisualVM` 等工具进行监控和分析。
- **代码优化**：避免创建过多短生命周期对象，减少 GC 压力。