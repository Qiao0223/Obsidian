# 1. JVM 架构组成

JVM 的整体架构主要包括以下几个核心组件：

## 1.1. 类加载器子系统（Class Loader Subsystem）

负责将 `.class` 文件加载到内存中，并完成验证、准备、解析和初始化等步骤。类加载器采用双亲委派模型，包括：[维基百科](https://zh.wikipedia.org/wiki/Java%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8?utm_source=chatgpt.com)

- **引导类加载器（Bootstrap ClassLoader）**：加载 Java 核心类库。
- **扩展类加载器（Extension ClassLoader）**：加载扩展类库。
- **应用类加载器（Application ClassLoader）**：加载应用程序的类。

这种机制确保了 Java 核心类的安全性和一致性。

## 1.2. 运行时数据区（Runtime Data Areas）

JVM 在执行 Java 程序时会划分出若干内存区域：

- **程序计数器（Program Counter Register）**：每个线程都有一个，用于指示当前线程执行的字节码行号。
- **Java 虚拟机栈（JVM Stack）**：每个线程私有，存储方法调用的局部变量、操作数栈、动态链接和方法出口等信息。
- **本地方法栈（Native Method Stack）**：为本地方法（Native）服务。
- **堆（Heap）**：所有线程共享，用于存放对象实例和数组，是垃圾回收器管理的主要区域。
- **方法区（Method Area）**：所有线程共享，存储已被虚拟机加载的类信息、常量、静态变量等。

在 JDK 8 之后，方法区被移除，取而代之的是元空间（Metaspace），它使用本地内存而非虚拟机内存。

## 1.3. 执行引擎（Execution Engine）

负责执行字节码，包括：

- **解释器（Interpreter）**：逐条解释执行字节码。
- **即时编译器（JIT Compiler）**：将热点代码编译为机器码，提高执行效率。

## 1.4. 本地接口（Native Interface）

提供与本地库（如 C/C++ 编写的库）的交互能力，允许 Java 程序调用本地方法。

# 2. Java 内存模型（Java Memory Model）

## 2.1. 核心概念

### 1. 主内存与工作内存

- **主内存（Main Memory）**：存储所有线程共享的变量，包括实例字段、静态字段和数组元素。
- **工作内存（Working Memory）**：每个线程私有，存储该线程使用的变量副本。线程对变量的所有操作（读取、写入）必须在工作内存中进行，不能直接访问主内存中的变量。

线程之间的变量值传递必须通过主内存完成，即一个线程修改了共享变量的值，必须刷新到主内存中，其他线程才能读取到最新的值。 

### 2. 可见性、原子性和有序性

- **可见性**：一个线程对共享变量的修改，其他线程能够立即得知。JMM 通过定义主内存和工作内存的交互规则，确保可见性。
- **原子性**：一个操作或多个操作要么全部执行完毕且不被中断，要么完全不执行。Java 提供了 `synchronized`、`volatile` 和原子类（如 `AtomicInteger`）来保证原子性。
- **有序性**：程序执行的顺序按照代码的先后顺序执行。JMM 允许编译器和处理器对指令进行重排序，但通过 `happens-before` 原则来保证有序性。

### 3. Happens-Before 原则

`happens-before` 是 JMM 中定义的一个重要原则，用于判断操作之间的执行顺序。如果一个操作 `A` `happens-before` 操作 `B`，那么操作 `A` 的结果对操作 `B` 是可见的，且操作 `A` 的执行顺序先于操作 `B`。

常见的 `happens-before` 关系包括：

- 程序顺序规则：在一个线程内，按照代码顺序，前面的操作 `happens-before` 后面的操作。
- 监视器锁规则：对一个锁的解锁 `happens-before` 于随后对这个锁的加锁。
- volatile 变量规则：对一个 `volatile` 变量的写操作 `happens-before` 于后续对这个变量的读操作。
- 线程启动规则：调用 `Thread.start()` 方法 `happens-before` 于该线程的每一个动作。
- 线程终结规则：线程中的所有操作 `happens-before` 于其他线程检测到该线程已经终止（通过 `Thread.join()` 等方式）。

## 2.2. 内存交互操作

JMM 定义了以下八种操作，用于描述主内存与工作内存之间的交互：

1. **lock**：作用于主内存变量，把一个变量标识为线程独占状态。
2. **unlock**：作用于主内存变量，释放被锁定的变量。
3. **read**：作用于主内存变量，把一个变量的值从主内存传输到线程的工作内存中，以便随后的 load 操作使用。
4. **load**：作用于工作内存变量，把 read 操作从主内存中得到的变量值放入工作内存的变量副本中。
5. **use**：作用于工作内存变量，把工作内存中的变量值传递给执行引擎。
6. **assign**：作用于工作内存变量，把一个从执行引擎接收到的值赋给工作内存的变量。
7. **store**：作用于工作内存变量，把工作内存中的变量值传送到主内存中，以便后续的 write 操作。
8. **write**：作用于主内存变量，把 store 操作从工作内存中得到的变量值放入主内存的变量中。

这些操作必须按顺序执行，以确保数据的一致性和可见性。

# 3. 垃圾回收机制

Java 的垃圾回收（Garbage Collection，GC）机制是 JVM 自动内存管理的核心功能，旨在自动识别并回收不再被使用的对象，从而释放内存资源，避免内存泄漏和程序崩溃。

## 3.1. 对象存活判断机制

JVM 主要通过以下两种方式判断对象是否仍然存活：

1. **引用计数法（Reference Counting）**：为每个对象添加一个引用计数器，每当有一个地方引用它时，计数器加一；引用失效时，计数器减一。当计数器为零时，表示对象可以被回收。该方法简单高效，但无法解决对象之间相互引用的问题，容易导致内存泄漏，因此已被淘汰。

2. **可达性分析算法（Reachability Analysis）**：从一组称为“GC Roots”的对象出发，沿着引用链向下搜索，能到达的对象被认为是存活的，无法到达的对象则被判定为可回收。GC Roots 通常包括：
    
    - 虚拟机栈中引用的对象
    - 方法区中类静态属性引用的对象
    - 方法区中常量引用的对象
    - 本地方法栈中 JNI（Native 方法）引用的对象

可达性分析算法是当前主流的对象存活判断机制。

## 3.2. 常见的垃圾回收算法

JVM 中常用的垃圾回收算法包括：

1. **标记-清除算法（Mark-Sweep）**：
    
    - **过程**：首先标记出所有需要回收的对象，然后统一回收这些对象所占用的内存。
    - **优点**：实现简单。
    - **缺点**：会产生大量不连续的内存碎片，影响程序性能。
    
2. **复制算法（Copying）**：
    
    - **过程**：将内存划分为两个等大小的区域，每次只使用其中一个。当该区域用完时，将存活的对象复制到另一个区域，然后清空当前区域。
    - **优点**：解决了内存碎片问题，适用于对象存活率低的场景。
    - **缺点**：内存利用率低，浪费了一半的空间。[CSDN](https://blog.csdn.net/abc123mma/article/details/128037723?utm_source=chatgpt.com)
        
3. **标记-整理算法（Mark-Compact）**：
    
    - **过程**：首先标记出所有需要回收的对象，然后将存活的对象向一端移动，最后清理掉边界以外的内存。
    - **优点**：解决了内存碎片问题，适用于对象存活率高的场景。
    - **缺点**：移动对象需要更新所有引用，成本较高。
    
4. **分代收集算法（Generational Collection）**：
    
    - **思想**：根据对象的生命周期将内存划分为新生代、老年代和永久代（或元空间），分别采用不同的回收算法。
    - **优点**：提高了回收效率，减少了停顿时间。
    - **缺点**：实现复杂，需要维护多个内存区域。

## 3.3. 常见的垃圾收集器

## 3.4. 垃圾回收的触发时机

垃圾回收的触发通常由以下情况引起：

- 新生代空间不足时，触发 Minor GC。
- 老年代空间不足时，触发 Major GC 或 Full GC。
- 调用 `System.gc()` 方法，建议 JVM 进行 Full GC，但不保证立即执行。
- 元空间（Metaspace）或永久代（PermGen）空间不足时，触发 Full GC。

## 3.5. 垃圾回收调优建议

- **选择合适的垃圾收集器**：根据应用的特点选择合适的垃圾收集器，例如对响应时间要求高的应用可以选择 G1、ZGC 或 Shenandoah。
- **设置合理的堆内存大小**：通过 `-Xms` 和 `-Xmx` 参数设置堆的初始和最大大小，避免频繁的垃圾回收。
- **监控垃圾回收情况**：使用 `jstat`、`jconsole`、`VisualVM` 等工具监控垃圾回收的频率和停顿时间，及时调整参数。
- **优化代码**：避免创建大量短生命周期的对象，减少对象的创建和销毁次数。

# 4. 类加载机制

# 5. 性能调优
