---
number headings: first-level 1, start-at 1, max 4, 1.1, auto, contents ^toc
---
黑马点评是一个以学习 Redis 为核心的实战项目，模拟类似大众点评的应用场景，涵盖了用户登录、商户查询、优惠券秒杀、探店笔记、好友关注、签到、UV统计等多个功能模块。该项目采用前后端分离架构，前端部署在 Nginx 上，后端基于 Spring Boot，使用 MyBatis-Plus、Redis 等技术栈。

# 1 项目架构与技术栈

- **架构模式**：前后端分离的单体应用。

- **后端技术**：

    - Spring Boot：快速构建项目框架。
    - MyBatis-Plus：简化数据库操作。
    - Redis：实现缓存、分布式锁、消息队列等功能。
    - Lombok、Hutool：提升开发效率。
    - Kafka：优化秒杀场景下的异步处理。

- **前端技术**：Vue.js，部署在 Nginx 上。

# 2 核心功能模块

## 2.1 用户登录与验证码验证

- 用户通过手机号接收验证码进行登录。
- 验证码存储在 Redis 中，设置过期时间。
- 登录成功后，生成 Token 并将用户信息存储在 Redis 中，实现会话管理。

## 2.2 商户查询与缓存优化

- 商户信息缓存至 Redis，提升查询性能。
- 采用缓存穿透、缓存击穿、缓存雪崩等问题的解决策略，如缓存空对象、互斥锁、逻辑过期等。

## 2.3 优惠券秒杀系统

- 实现全局唯一 ID 生成器，避免订单重复。
- 使用 Redis 实现库存预减，防止超卖。
- 引入分布式锁（如 Redisson）确保并发安全。
- 通过消息队列（如 RabbitMQ）异步处理订单，提升系统吞吐量。

## 2.4 探店笔记与点赞功能

- 用户可以发布探店笔记，记录消费体验。
- 实现点赞功能，使用 Redis 的 Set 结构存储点赞用户，防止重复点赞。
- 基于 Sorted Set 实现点赞排行榜，展示热门笔记。

## 2.5 好友关注与 Feed 流

- 用户可以关注其他用户，形成社交关系。
- 实现共同关注、取消关注等功能。
- 通过 Redis 的 List 或 Sorted Set 实现 Feed 流，推送关注用户的最新动态。

## 2.6 附近商户查询

- 利用 Redis 的 GEO 数据结构存储商户地理位置。
- 实现基于地理位置的附近商户查询功能。

## 2.7 用户签到与 UV 统计

- 使用 Redis 的 BitMap 实现用户签到功能，支持连续签到统计。
- 通过 HyperLogLog 实现 UV（独立访客）统计，节省内存空间。

# 3 用户登录

黑马点评的用户登录流程主要采用短信验证码（或邮件验证码）+手机号（或邮箱）的方式，结合Session/Redis存储以及拦截器进行登录状态校验。具体而言，当用户提交手机号或邮箱后，后台会生成一个随机验证码（通常为六位数字），并通过短信或邮件接口发送给用户，同时将验证码保存在Session 或 Redis 中。用户收到验证码后，将手机号/邮箱和验证码一起提交后台，后台从 Session 或 Redis 中取出原始验证码进行比对，验证通过后再根据手机号/邮箱查询或创建用户信息，并将用户信息封装为 DTO 存储到 Session 或以 `token` 形式存储到 Redis（Hash 结构中），然后将登录成功信息（如 `token`）返回给前端。后续用户访问时会在拦截器中，从 Cookie 中获取 `token` 或 SessionId，校验登录状态是否有效，若有效则放行并将用户信息放入 ThreadLocal，以便后续业务使用。整个流程还兼顾了分布式环境下 Session 共享的问题，并通过 DTO 机制对用户敏感信息进行脱敏处理。

## 3.1 发送验证码

### 3.1.1 验证码生成及存储

1. **生成六位随机验证码**  
    后端使用工具类随机生成一个六位数字验证码，并将该验证码与手机号（或邮箱）一一对应。生成方式通常是调用 Java 中的 `Random` 或其它验证码工具库来产生一个伪随机数。
    
2. **校验手机号/邮箱格式**
    - 当用户提交手机号时，后端会先调用正则表达式或专门的校验工具类验证手机号格式是否符合规范，若不合法则直接返回错误信息，提示“手机号格式错误”或“邮箱格式错误”。
    - 例如，检查手机号是否全为数字且长度为11位，或邮箱是否包含 `@` 且域名合法。
    
3. **存储验证码到 Session**
    - 初期的黑马点评实现基于传统 Servlet Session，将生成的验证码通过 `session.setAttribute("code", code)` 方式保存在 Session 中，Session 默认保存在服务器内存，由同一台 Tomcat 实例维护。
    - 若采用集群部署，Session 共享会存在不一致性问题，用户请求切换到不同节点时会导致 Session 丢失。
    
4. **升级至 Redis 存储**
    - 为了支持多机房或多实例部署，黑马点评后续将验证码存储迁移到 Redis 中，使用 `String` 类型，以 `login:code:[手机号]` 为 Key，Value 为验证码，设置 TTL（如 2 分钟或 120 秒），确保存储期间验证码有效。
    - 代码示例：
    - 这样可保证验证码在 Redis 集群中高效、快速地读取，且不同 Tomcat 实例共享同一 Redis 存储，解决了 Session 共享问题。
```
// 保存到 Redis 中，键为 login:code: + phone，过期时间 120 秒
stringRedisTemplate.opsForValue()
       .set(LOGIN_CODE_KEY + phone, code, LOGIN_CODE_TTL, TimeUnit.SECONDS);
```

### 3.1.2 发送渠道

- **短信发送**
    
    - 后端调用第三方短信服务（如阿里云短信、腾讯云短信、云片短信等）将验证码发送给用户手机。
    - 发送前可以在 Redis 中使用有序集合（ZSet）或 Set 对发送次数进行限制（如 5 分钟内不能重复发送；同一手机号一天发送次数上限），防止恶意刷码。
    
- **邮件发送**
    
    - 除短信验证码外，黑马点评也支持邮箱验证码模式，使用 JavaMail 或第三方邮件服务（如 Spring Boot 集成的 MailSender）发送验证码到用户邮箱。
    - 与短信模式类似，将验证码存储到 Redis 或 Session，再返回给前端提示“邮件已发送，请检查邮箱”。
    - 对邮件验证码亦可加入频率控制，如每5分钟只能发送一次；可以使用 Redis 的 ZSet 存储发送时间戳，检测最近发送记录。

## 3.2 验证码登录与注册

### 3.2.1 用户提交验证码、校验流程

1. **前端提交手机号/邮箱 + 验证码**
    - 用户在登录页面输入手机号（或邮箱）和收到的验证码，点击“登录/注册”。前端将数据封装为 `LoginFormDTO`（或类似 DTO），包含 `phone`（或 `email`）和 `code` 两个字段，通过 HTTP POST 提交到 `/user/login` 接口。
    
2. **后端校验验证码**
    - 后端先检查手机号/邮箱格式合法性，若不合格立即返回失败。
    - 从 Redis 中取值：
        若 `redisCode == null`，说明验证码过期或未发送，直接返回“验证码无效”；若 `!redisCode.equals(code)` 则返回“验证码错误”。
    - 若使用 Session 存储，则从 `HttpSession` 中通过 `session.getAttribute("code")` 取出，校验 `Object cacheCode` 与用户输入的 `code` 是否一致。
    
3. **注册或查询用户**
    - 验证通过后，根据手机号/邮箱在数据库中查询 `User` 实体（`select * from tb_user where phone = ?`）。若查询结果 `user == null`，则调用 `createUser(phone)` 创建新用户，设置 `phone`、`nickName`（可随机生成或默认 “用户+后四位”）、默认头像（随机或缺省），插入数据表。
    - 如果用户已存在，则直接获得该 `User` 对象。
    
4. **脱敏处理并封装为 DTO**
    - 为了避免将完整用户信息泄露给前端，黑马点评将 `User` 实体转换为 `UserDTO`，只保留必要的字段，如 `id`、`nickName`、`icon` 等；敏感字段如密码、手机号中间四位等会做脱敏处理。
    - 使用 `BeanUtil.copyProperties(user, UserDTO.class)` 等工具类快速拷贝到 DTO。
    
5. **保存登录状态**
    
    - **Session 模式**：将 `UserDTO` 对象 `session.setAttribute("user", userDTO)` 保存在 Session 中，以后基于 SessionId 自动识别登录状态。
    - **Redis 模式**：
        1. **生成 Token**：使用 `UUID.randomUUID().toString(true)`（去掉中划线）生成唯一 `token`，该 `token` 相当于会话标识符。
        2. **保存用户信息到 Redis**：将 `UserDTO` 转换为 `Map<String, String>` 后，通过 `stringRedisTemplate.opsForHash().putAll(LOGIN_USER_KEY + token, userMap)` 存储到 Redis Hash 中，并设置 TTL（如 30 分钟），用来维护登录状态。
        3. **返回 Token**：将生成的 `token` 放在 HTTP 响应结果中，前端通常将 `token` 存入 Cookie（如 `user_token`）或 LocalStorage，以便后续请求携带。
    
6. **返回登录结果给前端**
    - 返回 JSON 格式，例如 `{ "code": 0, "msg": "登录成功", "token": "xxxxx" }`，其中 `token` 在 Session 模式下会直接交给前端保管 Cookie；在 Redis 模式下前端需要将该 `token` 放入 `Authorization` Header 或 Cookie 中。

## 3.3 登录状态校验与拦截

### 3.3.1 基于 Session 的拦截

1. **拦截器配置**
    - 在 Spring Boot 中自定义 `LoginInterceptor` 并注册到 `WebMvcConfigurer` 中，对所有需要登录保护的 URL 添加拦截规则（`addPathPatterns("/api/user/**")` 等），排除 `/user/login`、`/user/code` 等无需登录接口。[blog.51cto.com](https://blog.51cto.com/u_16099276/10067178?utm_source=chatgpt.com)[blog.csdn.net](https://blog.csdn.net/weixin_65935065/article/details/132124345?utm_source=chatgpt.com)
    
2. **校验 Session 中是否存在用户信息**
    - 在 `preHandle` 方法中，通过 `HttpServletRequest.getSession(false)` 获取当前 Session，对比 `session != null && session.getAttribute("user") != null`，若不存在则返回 HTTP 401（未登录）或跳转到登录页面；若存在则将 `UserDTO` 放入 `ThreadLocal`（或一些上下文），方便后续 Controller 或 Service 获取当前登录用户。[blog.csdn.net](https://blog.csdn.net/weixin_65935065/article/details/132124345?utm_source=chatgpt.com)[blog.51cto.com](https://blog.51cto.com/u_16099276/10067178?utm_source=chatgpt.com)
        
3. **ThreadLocal 线程隔离**
    - 由于一个请求可能会被不同线程处理，为保证每个请求线程都能获取到正确的用户信息，拦截器会将 `UserDTO` 存入 `UserHolder.setUser(userDTO)`（`ThreadLocal` 实例），并在请求处理完成后清理线程中的 `ThreadLocal`，防止内存泄露。
    

### 3.3.2 基于 Redis Token 的拦截

1. **获取 Token 并校验**
    - 拦截器从 `HttpServletRequest` 中取出前端传递的 `token`（可以是 Header `Authorization: Bearer [token]` 或 Cookie 等），若 `token == null`，直接返回未登录。
    - 使用 `stringRedisTemplate.opsForHash().entries(LOGIN_USER_KEY + token)` 从 Redis 中取出对应的用户 Hash，若结果为空或 TTL 过期，则认为登录失效，需要重新登录；若存在则获取用户信息并封装为 `UserDTO`。
    
2. **续期**
    - 为防止用户长时间在线后频繁操作导致 Session 过期，拦截器会自动在每次请求时，将 Redis 中该 Token 的 TTL 再次设置为初始值（如 30 分钟），实现“登录延迟”（Sliding Expiration）。
    
3. **将 `UserDTO` 放入 ThreadLocal**
    - 与 Session 模式类似，成功校验后将 `UserDTO` 存入 `ThreadLocal`，以便后续业务层直接调用 `UserHolder.getUser()` 获取当前登录用户。请求结束后在 `afterCompletion` 中清除。

## 3.4 验证码防刷设计与限流

### 3.4.1 单机 Session 存储下的限流

1. **5 分钟内禁止重复发送（`limit:onelevel:[phone]`）**
    - 在 Redis 中使用 Set 结构存储已经发送过验证码的手机号，到达 5 分钟时通过定时任务或过期策略清除 Set 中对应手机号，避免同一手机号在短时间内多次请求验证码。
    
2. **更细粒度的间隔限制**
    - 也可以使用有序集合（ZSet）将发送时间戳记录在集合中，每次发送前检查最近一个发送时间是否距离当前时间 < 60 秒，若过于频繁则拒绝。
    
3. **每日发送上限**
    - 可以在 Redis 中针对同一手机号维护计数器（如 `limit:daily:[phone]`），每天零点自动重置；当计数器大于设定值（如 10 次）时，禁止当天继续发送。
    

### 3.4.2 分布式环境下的限流

1. **基于 Redis 的全局限流**
    - 在集群环境下，所有实例共用同一 Redis，通过原子命令 `INCR`、`EXPIRE` 实现全局限流，保证无论请求落在哪台服务器，限流策略都一致。
    
2. **使用令牌桶或漏桶算法**
    - 也可整合 Redis + Lua 脚本，采用令牌桶或漏桶算法，为更精细的限速提供保障，防止分布式环境下在高并发情况下出现“雪崩”或“击穿”问题。

## 3.5 安全与优化

## 3.6 安全与优化

### 3.6.1 防止验证码枚举与暴力破解

1. **验证码有效期短**
    - 将验证码在 Redis 中 TTL 设置为较短时间（如 120 秒），过期后自动删除，避免长时间被猜解。
    
2. **错误次数限制**
    - 在 Redis 中维护一个“校验错误计数”键，如 `login:fail:[phone]`，当同一手机号连续 5 次输入错误验证码后，临时屏蔽 10 分钟，锁定登录，防止暴力破解。
    
3. **验证码字符复杂度**
    - 可以将六位数字升级为包含字母的混合验证码，增加破解难度。

### 3.6.2 隐藏敏感信息与 DTO 设计

1. **去除敏感字段**
    - `User` 实体中可能包含密码（或 OpenID）、手机号、身份证号等敏感字段，使用 `UserDTO` 仅保留 `id`、`nickName`、`icon`、`gender` 等非敏感字段返回给前端。
    
2. **使用 BeanUtil 进行深拷贝**
    - 利用 `BeanUtil.copyProperties(user, UserDTO.class)` 或 `BeanUtils`、`ModelMapper` 等工具快速拷贝属性，并对敏感字段进行手动设 `null` 或脱敏处理。
    
3. **HttpOnly & Secure Cookie**
    - 若使用 Cookie 存储 Token，设置 `HttpOnly` 标记，防止前端 JavaScript 读取；在 HTTPS 环境下同时设置 `Secure`，防止 Token 在明文 HTTP 时泄露。

### 3.6.3 MVC 结构与分层

#### 3.6.3.1 Controller 层
负责接收前端请求，将参数封装到 `LoginFormDTO`（包含 `phone`、`code` 等），调用 Service 完成业务逻辑。
```
@PostMapping("/login")
public Result login(@RequestBody LoginFormDTO loginForm) {
    return userService.login(loginForm);
}
```

#### 3.6.3.2 Service 层
负责核心业务逻辑：校验手机号/邮箱格式、从 Redis/Session 获取验证码、查询/创建用户、生成 Token、保存到 Redis/Session、返回 DTO 等。
```
public Result login(LoginFormDTO loginForm) {
    // 校验手机号
    if (RegexUtils.isPhoneInvalid(loginForm.getPhone())) {
        return Result.fail("手机号码格式错误");
    }
    // 从 Redis 获取验证码
    String redisCode = stringRedisTemplate.opsForValue().get(LOGIN_CODE_KEY + phone);
    if (redisCode == null || !redisCode.equals(loginForm.getCode())) {
        return Result.fail("验证码错误");
    }
    // 查询或创建用户
    User user = query().eq("phone", phone).one();
    if (user == null) {
        user = createUser(phone);
    }
    // 脱敏并转换 DTO
    UserDTO userDTO = BeanUtil.copyProperties(user, UserDTO.class);
    // 生成 Token 并保存到 Redis
    String token = UUID.randomUUID().toString(true);
    Map<String, Object> userMap = BeanUtil.beanToMap(userDTO);
    stringRedisTemplate.opsForHash().putAll(LOGIN_USER_KEY + token, userMap);
    stringRedisTemplate.expire(LOGIN_USER_KEY + token, LOGIN_USER_TTL, TimeUnit.MINUTES);
    return Result.ok(token);
}
```

#### 3.6.3.3 Interceptor 层
负责对需要登录的接口进行拦截，从 Redis 或 Session 校验登录状态，将 `UserDTO` 放入 `UserHolder`（ThreadLocal），并在请求完成后清理。

#### 3.6.3.4 DAO 层
使用 MyBatis-Plus 或 MyBatis 操作数据库，对于新用户使用 `insert`，以及通过 `query().eq("phone", phone).one()` 查询。

## 3.7 典型代码示例

### 3.7.1 生成并发送验证码

```
/**
 * 发送短信验证码
 */
@PostMapping("/sendCode")
public Result sendCode(@RequestParam("phone") String phone, HttpSession session) {
    // 1. 校验手机号格式
    if (!RegexUtils.isPhoneValid(phone)) {
        return Result.fail("手机号格式错误");
    }
    // 2. 生成随机验证码
    String code = RandomUtil.randomNumbers(6);
    // 3. 将验证码存入 Redis，并设置 TTL
    stringRedisTemplate.opsForValue()
        .set(LOGIN_CODE_KEY + phone, code, LOGIN_CODE_TTL, TimeUnit.MINUTES);
    // 4. 调用短信服务发送验证码
    smsService.sendSms(phone, code);
    return Result.ok();
}
```
捕获并抛出可能的短信发送异常，同时在 Redis 中进行限流控制（如：同一手机号 1 分钟内只能发送一次）。

### 3.7.2 登录逻辑
```
/**
 * 短信验证码登录
 */
@PostMapping("/login")
public Result login(@RequestBody LoginFormDTO loginForm, HttpSession session) {
    // 1. 校验手机号格式
    String phone = loginForm.getPhone();
    if (RegexUtils.isPhoneInvalid(phone)) {
        return Result.fail("手机号码格式错误！");
    }
    // 2. 从 Redis 获取验证码并校验
    String redisCode = stringRedisTemplate.opsForValue().get(LOGIN_CODE_KEY + phone);
    if (redisCode == null || !redisCode.equals(loginForm.getCode())) {
        return Result.fail("验证码错误！");
    }
    // 3. 查询用户；若不存在则创建
    User user = userService.query().eq("phone", phone).one();
    if (user == null) {
        user = userService.createUserWithPhone(phone);
    }
    // 4. 脱敏并转换 DTO
    UserDTO userDTO = BeanUtil.copyProperties(user, UserDTO.class);
    // 5. 生成 Token 并保存到 Redis
    String token = UUID.randomUUID().toString(true);
    Map<String, Object> userMap = BeanUtil.beanToMap(userDTO, new HashMap<>(),
        CopyOptions.create().setIgnoreNullValue(true)
                           .setFieldValueEditor((fieldName, fieldValue) -> fieldValue.toString()));
    stringRedisTemplate.opsForHash().putAll(LOGIN_USER_KEY + token, userMap);
    // 6. 设置登录状态过期时间
    stringRedisTemplate.expire(LOGIN_USER_KEY + token, LOGIN_USER_TTL, TimeUnit.MINUTES);
    return Result.ok(token);
}
```
方法 `createUserWithPhone` 中会初始化 `User` 实体，设置默认 `nickName`、`avatar` 等属性，并保存到数据库。

### 3.7.3 拦截器示例

```
@Component
public class LoginInterceptor implements HandlerInterceptor {
    @Autowired
    private StringRedisTemplate stringRedisTemplate;

    @Override
    public boolean preHandle(HttpServletRequest request,
                             HttpServletResponse response,
                             Object handler) throws Exception {
        // 1. 获取 Token
        String token = request.getHeader("Authorization");
        if (StrUtil.isBlank(token)) {
            response.setStatus(HttpStatus.UNAUTHORIZED.value());
            return false;
        }
        // 2. 从 Redis 获取用户数据
        Map<Object, Object> userMap = stringRedisTemplate.opsForHash()
                                     .entries(LOGIN_USER_KEY + token);
        if (userMap.isEmpty()) {
            response.setStatus(HttpStatus.UNAUTHORIZED.value());
            return false;
        }
        // 3. 将 Map 转回 UserDTO 并存入 ThreadLocal
        UserDTO userDTO = BeanUtil.fillBeanWithMap(userMap, new UserDTO(), true);
        UserHolder.saveUser(userDTO);
        // 4. 刷新过期时间（续期）
        stringRedisTemplate.expire(LOGIN_USER_KEY + token, LOGIN_USER_TTL, TimeUnit.MINUTES);
        return true;
    }

    @Override
    public void afterCompletion(HttpServletRequest request,
                                HttpServletResponse response,
                                Object handler,
                                Exception ex) throws Exception {
        // 清理 ThreadLocal
        UserHolder.removeUser();
    }
}
```
在 `WebConfig` 中注册拦截器，排除 `/sendCode`、`/login` 等无需登录接口。

# 4 商户查询与缓存优化

黑马点评的商户查询与缓存优化主要基于**Redis**实现高性能缓存，辅以**双写一致性**、**空值填充**、**互斥锁/逻辑过期**等策略来解决**缓存穿透**、**缓存击穿**和**缓存雪崩**等常见问题，并可选用**Caffeine**在应用层配合 Redis 构建二级缓存，进一步提升查询效率与可用性。整体流程中，当接收到商户 ID 查询请求时，系统首先从 Redis 缓存中读取数据，若存在则直接返回；若缓存未命中，则通过分布式锁或逻辑过期机制避免热点重建压力，从数据库加载后写回缓存，同时设置合理的 TTL 或逻辑过期时间。为了防止数据库中不存在的商户频繁请求导致缓存穿透，系统会对不存在的商户在 Redis 中写入空对象并短期过期；而对于可能集中在同一时刻大量缓存失效导致的缓存雪崩，系统会在设置 TTL 时加入随机抖动，并可实用本地 Caffeine 缓存做一级缓存，以降低对 Redis 的瞬时并发访问压力。最后，通过合理的缓存更新策略（如先写库再删缓存）确保商户信息更新时的双写一致性，保证系统在高并发环境下依旧具备稳定的响应能力和数据准确性。

## 4.1 基础缓存模型与双写一致

### 4.1.1 查询时的缓存读取逻辑
- **优先从 Redis 缓存读取商户信息**  
    在 `ShopService.queryById(id)` 方法中，系统首先调用 Redis 客户端尝试获取 Key 为 `shop:[id]` 的缓存数据，如果命中则直接将反序列化后的 `Shop` 对象返回给调用方，并结束整个查询流程。
- **缓存未命中则查询数据库并回写缓存**  
    若 Redis 中不存在对应 Key 或已过期，则执行数据库 `SELECT * FROM shop WHERE id = ?` 查询，将查询结果转为 `Shop` 对象后，再将其序列化并写入 Redis 缓存，同时设置 TTL（如 30 分钟）。这样能让后续相同 ID 的请求直接读取缓存，从而极大地减少数据库压力。

### 4.1.2 更新时的缓存双写策略
- **先更新数据库，再删除缓存**  
    在对商户信息进行更新操作时，首先执行 `UPDATE shop SET ... WHERE id = ?` 更新数据库；之后立即调用 `redisTemplate.delete("shop:" + id)` 删除缓存，使得下次查询时能够重新从数据库加载最新的数据并回写缓存，以保证读写一致性。
- **保障原子性与一致性**  
    为了避免在并发场景下出现“先删后写”或“先写后删”引起的脏数据，通常要求在业务逻辑中将数据库更新与缓存删除封装在同一个事务范围内执行，或通过使用分布式事务/消息队列等方式确保顺序与可靠性

## 4.2 解决缓存穿透

- **当数据库查询结果为 null 时，向缓存写入空对象**  
    在 `ShopService.queryById(id)` 查询流程中，如果数据库中不存在对应 ID 的商户，系统会在 Redis 中写入一个空值（例如空的 JSON 或者标记对象），并设置较短的 TTL（如 1 分钟）。将空值写入缓存后，后续对同一不存在商户的请求将直接从缓存命中空值并快速返回，避免打到数据库。
- **短 TTL 限制对空值的过期时间**  
    对空值设置较短的过期时间能够平衡防穿透效果与缓存空间利用率，防止空值在缓存中长期占用内存。

## 4.3 解决缓存击穿

### 4.3.1 互斥锁（Mutex）方案

- **获取分布式锁后加载数据库**  
    当 `queryById` 发现缓存未命中且未读到空值时，先尝试使用如 `SETNX` 或 Redisson 等方式加一个分布式锁（Key 形如 `lock:shop:[id]`）。只有成功获取锁的线程才会去数据库加载并写缓存，其他线程则进入自旋等待或短暂休眠后重试，从而避免 N 个线程同时查询数据库。
    
- **加载完成后释放锁与写入缓存**  
    获取锁的线程完成数据库查询后，将结果写入 Redis 缓存并设置合理 TTL，然后释放锁。此时其他等待线程再次尝试读取缓存，得到缓存后方可结束，避免重复查询数据库。
```
public Shop queryById(Long id) {
    // 1. 查询缓存
    Shop shop = redisTemplate.opsForValue().get("shop:" + id);
    if (shop != null) {
        return shop;
    }
    // 2. 缓存未命中，尝试获取锁
    String lockKey = "lock:shop:" + id;
    boolean acquired = tryLock(lockKey, timeout);
    if (acquired) {
        try {
            // Double check 获取锁后再次验证缓存，防止重复加载
            shop = redisTemplate.opsForValue().get("shop:" + id);
            if (shop != null) {
                return shop;
            }
            // 3. 缓存仍未命中，查询数据库
            shop = shopMapper.selectById(id);
            if (shop == null) {
                // 写入空值防穿透
                redisTemplate.opsForValue().set("shop:" + id, "", 60, TimeUnit.SECONDS);
                return null;
            }
            // 4. 将查询结果写入缓存
            redisTemplate.opsForValue().set("shop:" + id, shop, 30, TimeUnit.MINUTES);
            return shop;
        } finally {
            // 5. 释放锁
            unlock(lockKey);
        }
    } else {
        // 获取锁失败，短暂等待后重试
        Thread.sleep(50);
        return queryById(id);
    }
}
```

### 4.3.2 逻辑过期方案

- **在缓存中同时存储数据和过期时间戳**  
    与直接依赖 Redis TTL 不同，逻辑过期通常会把 `ShopData` 与 `expireTime` 一同封装到一个对象中存储在 Redis，如：
    `{   "data": {/* Shop 对象字段 */},   "expireTime": "2025-06-04T08:00:00" }`
    缓存中只设置一个很长的 Redis TTL（例如 1 天），由逻辑过期字段控制热度。
    
- **访问时检查逻辑过期时间**  
    当用户请求查询时，先从 Redis 反序列化该封装对象，判断 `expireTime` 是否在当前时间之后，如果尚未过期，则直接返回 `data`；如果已经过期，则让第一个检测到过期的线程异步刷新数据库并更新缓存（利用互斥锁或单线程池），而主线程仍可直接返回旧数据以保证高可用。这样既保证了缓存并不会瞬间全部失效，又能及时异步更新数据。

## 4.4 解决缓存雪崩

### 4.4.1 随机 TTL
在给 Redis 写入商户缓存时，不要将所有 Key 都统一设置为一个固定的过期时间，而是对 TTL 增加一个随机值，例如 `base + random(0~300)` 秒，使得缓存过期时钟分散，避免集中过期造成的并发打库。

### 4.4.2 使用本地 Caffeine 构建二级缓存
- 在应用层内存中集成 Caffeine作为一级缓存，将热点商户数据先缓存在本地内存中，当本地缓存未命中时再访问 Redis；这样可以进一步减轻 Redis 压力。
- 以 Caffeine 和 Redis 组合的双重缓存可以分为：
    1. **Caffeine（一级）**：超短 TTL（如 1 分钟），内存读取速度极快；
    2. **Redis（二级）**：稍长 TTL（如 30 分钟+随机抖动），跨进程共享，支持分布式。
在 `ShopServiceImpl.queryById` 中增加本地缓存查找逻辑：
```
public Shop queryById(Long id) {
    // 1. 本地 Caffeine 缓存读取
    Shop shop = caffeineCache.getIfPresent(id);
    if (shop != null) {
        return shop;
    }
    // 2. 二级 Redis 缓存读取（参照前面流程）
    shop = redisTemplate.opsForValue().get("shop:" + id);
    if (shop != null) {
        // 3. 命中后回写到本地 Caffeine 缓存，并返回
        caffeineCache.put(id, shop);
        return shop;
    }
    // …（后续数据库加载/互斥锁/逻辑过期等处理）
}
```
通过这种“先本地再 Redis，再数据库”的三级查找链路，可显著降低 Redis 与数据库在高并发场景下的压力，同时借助 Caffeine 本地缓存的高命中率提升性能。

## 4.5 具体实现要点与最佳实践

### 4.5.1 Redis Key 设计与序列化

- **Key 命名规范**  
    建议使用前缀 + 对象名 + ID 的方式，如 `shop:123`，方便定位与清理缓存。
    
- **序列化方式**
    - 对于简单数据，可使用 JSON 序列化（如 Jackson `ObjectMapper`）存储到 Redis；或者使用 Spring Data Redis 默认的 `JdkSerializationRedisSerializer`。
    - 对于性能敏感场景，可以考虑使用二进制序列化（如 Protostuff、Kryo），进一步减少网络与存储开销。

### 4.5.2 分布式锁的选择与实现

- **基于 Redis 的 `SETNX` + 过期时间**
    - 最简单的分布式锁：调用 `SET resource_name my_random_value NX PX 30000`，确保只有一个线程能成功设置锁；使用随机值避免误删问题；加锁失败后可通过自旋/延迟重试的方式获取。
    
- **使用 Redisson 简化锁管理**
    - Redisson 库封装了分布式锁功能，使得获取锁、续期和释放更安全便捷，无需手动管理随机值、心跳与 Lua 脚本。
```
RLock lock = redissonClient.getLock("lock:shop:" + id);
boolean acquired = lock.tryLock(100, 10, TimeUnit.SECONDS);
if (acquired) {
    try {
        // 执行业务
    } finally {
        lock.unlock();
    }
}
```
Redisson 默认对锁进行 WatchDog 扩展，避免因业务执行时间稍长导致锁过期后被误释放。

## 4.6 源码示例摘录

### 4.6.1 `ShopServiceImpl.queryById` 核心代码
该代码实现了**缓存穿透防护**（空值写入）、**缓存击穿防护**（Redisson 分布式锁 + double-check）、**缓存雪崩防护**（随机 TTL）以及**数据库更新后删除缓存保证双写一致性**。
```
@Service
public class ShopServiceImpl implements IShopService {

    @Autowired
    private StringRedisTemplate redisTemplate;

    @Autowired
    private ShopMapper shopMapper;

    @Autowired
    private RedissonClient redissonClient;

    // 查询商户并实现缓存穿透、缓存击穿、逻辑过期等
    public Shop queryById(Long id) {
        // 1. 缓存读取
        String shopJson = redisTemplate.opsForValue().get("shop:" + id);
        if (StrUtil.isNotBlank(shopJson)) {
            return JSONUtil.toBean(shopJson, Shop.class);
        }
        // 2. 判断是否为缓存空值，防止穿透
        if (shopJson != null && shopJson.equals("")) {
            return null;
        }
        // 3. 缓存未命中，获取分布式锁
        RLock lock = redissonClient.getLock("lock:shop:" + id);
        boolean isLock = false;
        try {
            isLock = lock.tryLock(3, 10, TimeUnit.SECONDS);
            if (isLock) {
                // 4. double-check 再次读取缓存
                shopJson = redisTemplate.opsForValue().get("shop:" + id);
                if (StrUtil.isNotBlank(shopJson)) {
                    return JSONUtil.toBean(shopJson, Shop.class);
                }
                // 5. 缓存仍未命中，查询数据库
                Shop shop = shopMapper.selectById(id);
                if (shop == null) {
                    // 6. 写入空值并设置短期过期
                    redisTemplate.opsForValue().set("shop:" + id, "", 60, TimeUnit.SECONDS);
                    return null;
                }
                // 7. 写入缓存并设置随机TTL，防止雪崩
                long expireTime = 1800 + RandomUtil.randomLong(300);
                redisTemplate.opsForValue().set("shop:" + id,
                    JSONUtil.toJsonStr(shop), expireTime, TimeUnit.SECONDS);
                return shop;
            } else {
                // 8. 未获取锁，短暂等待后重试
                Thread.sleep(50);
                return queryById(id);
            }
        } catch (InterruptedException e) {
            throw new RuntimeException(e);
        } finally {
            if (isLock) {
                lock.unlock();
            }
        }
    }

    @Transactional
    public void updateShop(Shop shop) {
        // 1. 更新数据库
        shopMapper.updateById(shop);
        // 2. 删除缓存，保证下次查询加载最新数据
        redisTemplate.delete("shop:" + shop.getId());
    }
}
```

### 4.6.2 二级缓存示例
该示例在**本地 Caffeine 缓存**基础上，再访问 **Redis 二级缓存**，最后才打数据库，能够将热点数据“沉淀”到应用内存，降低 Redis 请求压力。
```
@Configuration
public class CacheConfig {

    @Bean
    public Cache<Object, Object> caffeineCache() {
        return Caffeine.newBuilder()
                .initialCapacity(100)
                .maximumSize(1000)
                .expireAfterWrite(1, TimeUnit.MINUTES)
                .build();
    }
}

@Service
public class ShopServiceImpl implements IShopService {

    @Autowired
    private Cache<Long, Shop> caffeineCache;

    @Autowired
    private StringRedisTemplate redisTemplate;

    @Autowired
    private ShopMapper shopMapper;

    public Shop queryById(Long id) {
        // 1. 先查 Caffeine 本地缓存
        Shop shop = caffeineCache.getIfPresent(id);
        if (shop != null) {
            return shop;
        }
        // 2. 查 Redis 缓存
        String shopJson = redisTemplate.opsForValue().get("shop:" + id);
        if (StrUtil.isNotBlank(shopJson)) {
            shop = JSONUtil.toBean(shopJson, Shop.class);
            // 3. 回写 Caffeine 缓存
            caffeineCache.put(id, shop);
            return shop;
        }
        // 4. 缓存未命中，走互斥锁加载 DB 并回写双缓存
        shop = loadShopWithMutex(id);
        if (shop != null) {
            caffeineCache.put(id, shop);
        }
        return shop;
    }

    private Shop loadShopWithMutex(Long id) {
        // 同前面的获取分布式锁逻辑，用于从数据库加载，
        // 写入 Redis，并返回 Shop 对象
        // ...
        return shop;
    }
}
```

## 4.7 典型问题与可选方案

- **缓存穿透的替代方案**
    - 除空值填充外，还可结合**布隆过滤器**（Bloom Filter）预先存储所有合法商户 ID，当请求走向 Redis 之前先查询布隆过滤器，若布隆过滤器判定该 ID 不存在，则直接返回 null，从而避免多余的缓存/数据库读取。
    
- **缓存雪崩的分布式限流**
    - 当大规模缓存同时失效时，可先对查询请求进行限流或降级处理（如返回默认值、直接拒绝），并启动**后台预热**或**异步批量加载**策略，将热点商户提前加载到缓存。
    
- **一致性哈希与分片缓存**
    - 对于超大规模商户数据，可通过 Redis Cluster 或一致性哈希将不同 ID 范围分片到不同节点，避免单个 Redis 实例成为瓶颈；同时结合本地缓存能够更好地支撑千万级 QPS。
    
- **读写分离与异步更新**
    - 将数据库架构设计为主从复制，查询走从库，写走主库；更新业务则在主库写入后异步同步到从库，并通过消息队列异步删除缓存，以缩短缓存失效到重建的时间窗口。

## 4.8 流程图

![[黑马点评商户查询.svg]]













