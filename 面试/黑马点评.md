---
number headings: first-level 1, start-at 1, max 3, 1.1, auto, contents ^toc
---
黑马点评是一个以学习 Redis 为核心的实战项目，模拟类似大众点评的应用场景，涵盖了用户登录、商户查询、优惠券秒杀、探店笔记、好友关注、签到、UV统计等多个功能模块。该项目采用前后端分离架构，前端部署在 Nginx 上，后端基于 Spring Boot，使用 MyBatis-Plus、Redis 等技术栈。

# 1 项目架构与技术栈

- **架构模式**：前后端分离的单体应用。

- **后端技术**：

    - Spring Boot：快速构建项目框架。
    - MyBatis-Plus：简化数据库操作。
    - Redis：实现缓存、分布式锁、消息队列等功能。
    - Lombok、Hutool：提升开发效率。
    - Kafka：优化秒杀场景下的异步处理。

- **前端技术**：Vue.js，部署在 Nginx 上。

# 2 核心功能模块

## 2.1 用户登录与验证码验证

- 用户通过手机号接收验证码进行登录。
- 验证码存储在 Redis 中，设置过期时间。
- 登录成功后，生成 Token 并将用户信息存储在 Redis 中，实现会话管理。

## 2.2 商户查询与缓存优化

- 商户信息缓存至 Redis，提升查询性能。
- 采用缓存穿透、缓存击穿、缓存雪崩等问题的解决策略，如缓存空对象、互斥锁、逻辑过期等。

## 2.3 优惠券秒杀系统

- 实现全局唯一 ID 生成器，避免订单重复。
- 使用 Redis 实现库存预减，防止超卖。
- 引入分布式锁（如 Redisson）确保并发安全。
- 通过消息队列（如 RabbitMQ）异步处理订单，提升系统吞吐量。

## 2.4 探店笔记与点赞功能

- 用户可以发布探店笔记，记录消费体验。
- 实现点赞功能，使用 Redis 的 Set 结构存储点赞用户，防止重复点赞。
- 基于 Sorted Set 实现点赞排行榜，展示热门笔记。

## 2.5 好友关注与 Feed 流

- 用户可以关注其他用户，形成社交关系。
- 实现共同关注、取消关注等功能。
- 通过 Redis 的 List 或 Sorted Set 实现 Feed 流，推送关注用户的最新动态。

## 2.6 附近商户查询

- 利用 Redis 的 GEO 数据结构存储商户地理位置。
- 实现基于地理位置的附近商户查询功能。

## 2.7 用户签到与 UV 统计

- 使用 Redis 的 BitMap 实现用户签到功能，支持连续签到统计。
- 通过 HyperLogLog 实现 UV（独立访客）统计，节省内存空间。

# 3 用户登录

黑马点评的用户登录流程主要采用短信验证码（或邮件验证码）+手机号（或邮箱）的方式，结合Session/Redis存储以及拦截器进行登录状态校验。具体而言，当用户提交手机号或邮箱后，后台会生成一个随机验证码（通常为六位数字），并通过短信或邮件接口发送给用户，同时将验证码保存在Session 或 Redis 中。用户收到验证码后，将手机号/邮箱和验证码一起提交后台，后台从 Session 或 Redis 中取出原始验证码进行比对，验证通过后再根据手机号/邮箱查询或创建用户信息，并将用户信息封装为 DTO 存储到 Session 或以 `token` 形式存储到 Redis（Hash 结构中），然后将登录成功信息（如 `token`）返回给前端。后续用户访问时会在拦截器中，从 Cookie 中获取 `token` 或 SessionId，校验登录状态是否有效，若有效则放行并将用户信息放入 ThreadLocal，以便后续业务使用。整个流程还兼顾了分布式环境下 Session 共享的问题，并通过 DTO 机制对用户敏感信息进行脱敏处理。

## 3.1 发送验证码

### 3.1.1 验证码生成及存储

1. **生成六位随机验证码**  
    后端使用工具类随机生成一个六位数字验证码，并将该验证码与手机号（或邮箱）一一对应。生成方式通常是调用 Java 中的 `Random` 或其它验证码工具库来产生一个伪随机数。
    
2. **校验手机号/邮箱格式**
    - 当用户提交手机号时，后端会先调用正则表达式或专门的校验工具类验证手机号格式是否符合规范，若不合法则直接返回错误信息，提示“手机号格式错误”或“邮箱格式错误”。
    - 例如，检查手机号是否全为数字且长度为11位，或邮箱是否包含 `@` 且域名合法。
    
3. **存储验证码到 Session**
    - 初期的黑马点评实现基于传统 Servlet Session，将生成的验证码通过 `session.setAttribute("code", code)` 方式保存在 Session 中，Session 默认保存在服务器内存，由同一台 Tomcat 实例维护。
    - 若采用集群部署，Session 共享会存在不一致性问题，用户请求切换到不同节点时会导致 Session 丢失。
    
4. **升级至 Redis 存储**
    - 为了支持多机房或多实例部署，黑马点评后续将验证码存储迁移到 Redis 中，使用 `String` 类型，以 `login:code:[手机号]` 为 Key，Value 为验证码，设置 TTL（如 2 分钟或 120 秒），确保存储期间验证码有效。
    - 代码示例：
    - 这样可保证验证码在 Redis 集群中高效、快速地读取，且不同 Tomcat 实例共享同一 Redis 存储，解决了 Session 共享问题。
```
// 保存到 Redis 中，键为 login:code: + phone，过期时间 120 秒
stringRedisTemplate.opsForValue()
       .set(LOGIN_CODE_KEY + phone, code, LOGIN_CODE_TTL, TimeUnit.SECONDS);
```

### 3.1.2 发送渠道

- **短信发送**
    
    - 后端调用第三方短信服务（如阿里云短信、腾讯云短信、云片短信等）将验证码发送给用户手机。
    - 发送前可以在 Redis 中使用有序集合（ZSet）或 Set 对发送次数进行限制（如 5 分钟内不能重复发送；同一手机号一天发送次数上限），防止恶意刷码。
    
- **邮件发送**
    
    - 除短信验证码外，黑马点评也支持邮箱验证码模式，使用 JavaMail 或第三方邮件服务（如 Spring Boot 集成的 MailSender）发送验证码到用户邮箱。
    - 与短信模式类似，将验证码存储到 Redis 或 Session，再返回给前端提示“邮件已发送，请检查邮箱”。
    - 对邮件验证码亦可加入频率控制，如每5分钟只能发送一次；可以使用 Redis 的 ZSet 存储发送时间戳，检测最近发送记录。

## 3.2 验证码登录与注册

### 3.2.1 用户提交验证码、校验流程

1. **前端提交手机号/邮箱 + 验证码**
    - 用户在登录页面输入手机号（或邮箱）和收到的验证码，点击“登录/注册”。前端将数据封装为 `LoginFormDTO`（或类似 DTO），包含 `phone`（或 `email`）和 `code` 两个字段，通过 HTTP POST 提交到 `/user/login` 接口。
    
2. **后端校验验证码**
    - 后端先检查手机号/邮箱格式合法性，若不合格立即返回失败。
    - 从 Redis 中取值：
        若 `redisCode == null`，说明验证码过期或未发送，直接返回“验证码无效”；若 `!redisCode.equals(code)` 则返回“验证码错误”。
    - 若使用 Session 存储，则从 `HttpSession` 中通过 `session.getAttribute("code")` 取出，校验 `Object cacheCode` 与用户输入的 `code` 是否一致。
    
3. **注册或查询用户**
    - 验证通过后，根据手机号/邮箱在数据库中查询 `User` 实体（`select * from tb_user where phone = ?`）。若查询结果 `user == null`，则调用 `createUser(phone)` 创建新用户，设置 `phone`、`nickName`（可随机生成或默认 “用户+后四位”）、默认头像（随机或缺省），插入数据表。
    - 如果用户已存在，则直接获得该 `User` 对象。
    
4. **脱敏处理并封装为 DTO**
    - 为了避免将完整用户信息泄露给前端，黑马点评将 `User` 实体转换为 `UserDTO`，只保留必要的字段，如 `id`、`nickName`、`icon` 等；敏感字段如密码、手机号中间四位等会做脱敏处理。
    - 使用 `BeanUtil.copyProperties(user, UserDTO.class)` 等工具类快速拷贝到 DTO。
    
5. **保存登录状态**
    
    - **Session 模式**：将 `UserDTO` 对象 `session.setAttribute("user", userDTO)` 保存在 Session 中，以后基于 SessionId 自动识别登录状态。
    - **Redis 模式**：
        1. **生成 Token**：使用 `UUID.randomUUID().toString(true)`（去掉中划线）生成唯一 `token`，该 `token` 相当于会话标识符。
        2. **保存用户信息到 Redis**：将 `UserDTO` 转换为 `Map<String, String>` 后，通过 `stringRedisTemplate.opsForHash().putAll(LOGIN_USER_KEY + token, userMap)` 存储到 Redis Hash 中，并设置 TTL（如 30 分钟），用来维护登录状态。
        3. **返回 Token**：将生成的 `token` 放在 HTTP 响应结果中，前端通常将 `token` 存入 Cookie（如 `user_token`）或 LocalStorage，以便后续请求携带。
    
6. **返回登录结果给前端**
    - 返回 JSON 格式，例如 `{ "code": 0, "msg": "登录成功", "token": "xxxxx" }`，其中 `token` 在 Session 模式下会直接交给前端保管 Cookie；在 Redis 模式下前端需要将该 `token` 放入 `Authorization` Header 或 Cookie 中。







